CX51 COMPILER V7.50   ITL                                                                  10/23/2014 09:48:34 PAGE 1   


CX51 COMPILER V7.50, COMPILATION OF MODULE ITL
OBJECT MODULE PLACED IN ITL.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\CX51.EXE ITL.c LARGE OBJECTADVANCED ROM(HUGE) OPTIMIZE(SIZE) BROWSE DEBUG

line level    source

   1          #define  __ITL_C__
   2          #include "ITL.h"
   3          #include "Serial1.h"
   4          #include "global.h"
   5          #include "debug.h" 
   6          #include "device.h"
   7          #include "string.h"
   8          #include "common.h"
   9          #include "scheduler.h"
  10          #include "VMC_PC.h"
  11          #include "IOInput.h"
  12          //#include "CommonFunction.h"
  13          
  14          
  15          //#define  ITL_DEBUG
  16          
  17          unsigned char xdata ITLMsgBuf[255];  //255
  18          
  19          SERAIL1PARAM  code ITLSerialParam =
  20          {
  21                  8, VERIFY_NULL, 1, 0x00, 0x96, 0x00
  22          };
  23          
  24          //const unsigned int code CrcTable[8*32]=
  25          const unsigned int xdata CrcTable[8*32]=
  26          {
  27             /*
  28             0x0000,0x8005,0x800F,0x000A,0x801B,0x001E,0x0014,0x8011,
  29             0x8033,0x0036,0x003C,0x8039,0x0028,0x802D,0x8027,0x0022,
  30             0x8063,0x0066,0x006C,0x8069,0x0078,0x807D,0x8077,0x0072,
  31             0x0050,0x8055,0x805F,0x005A,0x804B,0x004E,0x0044,0x8041,
  32             0x80C3,0x00C6,0x00CC,0x80C9,0x00D8,0x80DD,0x80D7,0x00D2,
  33             0x00F0,0x80F5,0x80FF,0x00FA,0x80EB,0x00EE,0x00E4,0x80E1,
  34             0x00A0,0x80A5,0x80AF,0x00AA,0x80BB,0x00BE,0x00B4,0x80B1,
  35             0x8093,0x0096,0x009C,0x8099,0x0088,0x808D,0x8087,0x0082,
  36             0x8183,0x0186,0x018C,0x8189,0x0198,0x819D,0x8197,0x0192,
  37             0x01B0,0x81B5,0x81BF,0x01BA,0x81AB,0x01AE,0x01A4,0x81A1,
  38             0x01E0,0x81E5,0x81EF,0x01EA,0x81FB,0x01FE,0x01F4,0x81F1,
  39             0x81D3,0x01D6,0x01DC,0x81D9,0x01C8,0x81CD,0x81C7,0x01C2,
  40             0x0140,0x8145,0x814F,0x014A,0x815B,0x015E,0x0154,0x8151,
  41             0x8173,0x0176,0x017C,0x8179,0x0168,0x816D,0x8167,0x0162,
  42             0x8123,0x0126,0x012C,0x8129,0x0138,0x813D,0x8137,0x0132,
  43             0x0110,0x8115,0x811F,0x011A,0x810B,0x010E,0x0104,0x8101,
  44             0x8303,0x0306,0x030C,0x8309,0x0318,0x831D,0x8317,0x0312,
  45             0x0330,0x8335,0x833F,0x033A,0x832B,0x032E,0x0324,0x8321,
  46             0x0360,0x8365,0x836F,0x036A,0x837B,0x037E,0x0374,0x8371,
  47             0x8353,0x0356,0x035C,0x8359,0x0348,0x834D,0x8347,0x0342,
  48             0x03C0,0x83C5,0x83CF,0x03CA,0x83DB,0x03DE,0x03D4,0x83D1,
  49             0x83F3,0x03F6,0x03FC,0x83F9,0x03E8,0x83ED,0x83E7,0x03E2,
  50             0x83A3,0x03A6,0x03AC,0x83A9,0x03B8,0x83BD,0x83B7,0x03B2,
  51             0x0390,0x8395,0x839F,0x039A,0x838B,0x038E,0x0384,0x8381,
  52             0x0280,0x8285,0x828F,0x028A,0x829B,0x029E,0x0294,0x8291,
  53             0x82B3,0x02B6,0x02BC,0x82B9,0x02A8,0x82AD,0x82A7,0x02A2,
  54             0x82E3,0x02E6,0x02EC,0x82E9,0x02F8,0x82FD,0x82F7,0x02F2,
  55             0x02D0,0x82D5,0x82DF,0x02DA,0x82CB,0x02CE,0x02C4,0x82C1,
CX51 COMPILER V7.50   ITL                                                                  10/23/2014 09:48:34 PAGE 2   

  56             0x8243,0x0246,0x024C,0x8249,0x0258,0x825D,0x8257,0x0252,
  57             0x0270,0x8275,0x827F,0x027A,0x826B,0x026E,0x0264,0x8261,
  58             0x0220,0x8225,0x822F,0x022A,0x823B,0x023E,0x0234,0x8231,
  59             0x8213,0x0216,0x021C,0x8219,0x0280,0x820D,0x8207,0x0202,
  60             */
  61             0x0000,0x8005,0x800F,0x000A,0x801B,0x001E,0x0014,0x8011,
  62             0x8033,0x0036,0x003C,0x8039,0x0028,0x802D,0x8027,0x0022,
  63             0x8063,0x0066,0x006C,0x8069,0x0078,0x807D,0x8077,0x0072,
  64             0x0050,0x8055,0x805F,0x005A,0x804B,0x004E,0x0044,0x8041,
  65             0x80C3,0x00C6,0x00CC,0x80C9,0x00D8,0x80DD,0x80D7,0x00D2,
  66             0x00F0,0x80F5,0x80FF,0x00FA,0x80EB,0x00EE,0x00E4,0x80E1,
  67             0x00A0,0x80A5,0x80AF,0x00AA,0x80BB,0x00BE,0x00B4,0x80B1,
  68             0x8093,0x0096,0x009C,0x8099,0x0088,0x808D,0x8087,0x0082,
  69             0x8183,0x0186,0x018C,0x8189,0x0198,0x819D,0x8197,0x0192,
  70             0x01B0,0x81B5,0x81BF,0x01BA,0x81AB,0x01AE,0x01A4,0x81A1,
  71             0x01E0,0x81E5,0x81EF,0x01EA,0x81FB,0x01FE,0x01F4,0x81F1,
  72             0x81D3,0x01D6,0x01DC,0x81D9,0x01C8,0x81CD,0x81C7,0x01C2,
  73             0x0140,0x8145,0x814F,0x014A,0x815B,0x015E,0x0154,0x8151,
  74             0x8173,0x0176,0x017C,0x8179,0x0168,0x816D,0x8167,0x0162,
  75             0x8123,0x0126,0x012C,0x8129,0x0138,0x813D,0x8137,0x0132,
  76             0x0110,0x8115,0x811F,0x011A,0x810B,0x010E,0x0104,0x8101,
  77             0x8303,0x0306,0x030C,0x8309,0x0318,0x831D,0x8317,0x0312,
  78             0x0330,0x8335,0x833F,0x033A,0x832B,0x032E,0x0324,0x8321,
  79             0x0360,0x8365,0x836F,0x036A,0x837B,0x037E,0x0374,0x8371,
  80             0x8353,0x0356,0x035C,0x8359,0x0348,0x834D,0x8347,0x0342,
  81             0x03C0,0x83C5,0x83CF,0x03CA,0x83DB,0x03DE,0x03D4,0x83D1,
  82             0x83F3,0x03F6,0x03FC,0x83F9,0x03E8,0x83ED,0x83E7,0x03E2,
  83             0x83A3,0x03A6,0x03AC,0x83A9,0x03B8,0x83BD,0x83B7,0x03B2,
  84             0x0390,0x8395,0x839F,0x039A,0x838B,0x038E,0x0384,0x8381,
  85             0x0280,0x8285,0x828F,0x028A,0x829B,0x029E,0x0294,0x8291,
  86             0x82B3,0x02B6,0x02BC,0x82B9,0x02A8,0x82AD,0x82A7,0x02A2,
  87             0x82E3,0x02E6,0x02EC,0x82E9,0x02F8,0x82FD,0x82F7,0x02F2,
  88             0x02D0,0x82D5,0x82DF,0x02DA,0x82CB,0x02CE,0x02C4,0x82C1,
  89             0x8243,0x0246,0x024C,0x8249,0x0258,0x825D,0x8257,0x0252,
  90             0x0270,0x8275,0x827F,0x027A,0x826B,0x026E,0x0264,0x8261,
  91             0x0220,0x8225,0x822F,0x022A,0x823B,0x023E,0x0234,0x8231,
  92             0x8213,0x0216,0x021C,0x8219,0x0208,0x820D,0x8207,0x0202
  93           };
  94          
  95          //-----------------------------------------------------------
  96          void ITLUpdateCrc( const unsigned char num )
  97          {
  98   1          unsigned char data addr = 0;
  99   1          addr = ( num ^ sysITLMission.crcH );
 100   1          sysITLMission.crcH = (unsigned char)(CrcTable[addr]>>8)^sysITLMission.crcL;
 101   1          sysITLMission.crcL = (unsigned char)(CrcTable[addr] & 0x00FF );
 102   1      }
 103          
 104          //-----------------------------------------------------------
 105          void ITLResetCrc( void )
 106          {
 107   1          sysITLMission.crcL = 0xFF;
 108   1          sysITLMission.crcH = 0xFF;
 109   1      }
 110          
 111          void ITLChnCtr()
 112          {
 113   1          sysITLMission.chnCtr1 = 0;
 114   1              sysITLMission.chnCtr2 = 0;
 115   1          
 116   1          if( SystemParameter.billValue[0] != 0   )
 117   1              {
CX51 COMPILER V7.50   ITL                                                                  10/23/2014 09:48:34 PAGE 3   

 118   2                      sysITLMission.chnCtr1 |= 0x01;
 119   2              }
 120   1              if( SystemParameter.billValue[1] != 0   )
 121   1              {
 122   2                      sysITLMission.chnCtr1 |= 0x02;
 123   2              }
 124   1              if( SystemParameter.billValue[2] != 0   )
 125   1              {
 126   2                      sysITLMission.chnCtr1 |= 0x04;
 127   2              }
 128   1              if( SystemParameter.billValue[3] != 0   )
 129   1              {
 130   2                      sysITLMission.chnCtr1 |= 0x08;
 131   2              }
 132   1              if( SystemParameter.billValue[4] != 0   )
 133   1              {
 134   2                      sysITLMission.chnCtr1 |= 0x10;
 135   2              }
 136   1              if( SystemParameter.billValue[5] != 0   )
 137   1              {
 138   2                      sysITLMission.chnCtr1 |= 0x20;
 139   2              }
 140   1              if( SystemParameter.billValue[6] != 0   )
 141   1              {
 142   2                      sysITLMission.chnCtr1 |= 0x40;
 143   2              }
 144   1              if( SystemParameter.billValue[7] != 0   )
 145   1              {
 146   2                      sysITLMission.chnCtr1 |= 0x80;
 147   2              }
 148   1          //---------------------------------------------------------
 149   1              #ifdef ITL_DEBUG
                      sysITLMission.chnCtr1 = 0xff;
                              sysITLMission.chnCtr2 = 0xff;
                      #endif
 153   1          //sysITLMission.chnCtr1 = 0xff;
 154   1              //sysITLMission.chnCtr2 = 0xff;
 155   1          //=========================================================
 156   1      
 157   1      }
 158          
 159          void ITLSerialInit( void )
 160          {       
 161   1              unsigned char data i=0;
 162   1          
 163   1              //DelayMs(1);
 164   1              ZhkHardSerialSwitch( 0 );
 165   1              //DelayMs(1);
 166   1              for( i=0; i<sizeof( SERAIL1PARAM ); i ++ )
 167   1              {
 168   2                      ZhkSerial1Param[ i ] = ITLSerialParam[ i ];
 169   2              }
 170   1              ZhkSerial1Init();
 171   1          memset( ITLMsgBuf, 0, sizeof(ITLMsgBuf) );   
 172   1      }
 173          
 174          unsigned char ITLBusUnpack( void )
 175          {
 176   1              unsigned char xdata  i=0, j=0, k=0, m=0;
 177   1              unsigned char xdata  len = 0;
 178   1              unsigned char xdata  seq = 0;
 179   1              unsigned char xdata  position = 0;
CX51 COMPILER V7.50   ITL                                                                  10/23/2014 09:48:34 PAGE 4   

 180   1              unsigned char xdata newMsg[255];
 181   1              
 182   1              //return 1;
 183   1          //-------------------------------------------------
 184   1              /*
 185   1          #ifdef ITL_DEBUG
 186   1              return 1;
 187   1          #endif
 188   1              */
 189   1          //=================================================
 190   1      
 191   1              while( !ZhkSerial1IsRxBufNull() )
 192   1              {
 193   2                      for( i=0; i<sizeof( ITLMsgBuf )-1; i++ )
 194   2                      {
 195   3                              ITLMsgBuf[i] = ITLMsgBuf[i+1];
 196   3                      }
 197   2                      ITLMsgBuf[sizeof(ITLMsgBuf)-1] = ZhkSerial1GetCh();
 198   2              }
 199   1      
 200   1          for( i=0; i<=sizeof(ITLMsgBuf)-6; i++ )
 201   1              {
 202   2                  //Check the SF
 203   2                      if( ITLMsgBuf[i] != ITL_MSG_STX ) 
 204   2                              continue;
 205   2                      //Check the len
 206   2                      seq = ITLMsgBuf[i+1];
 207   2                      if( !((seq==ITL_MSG_SEQ_0)||(seq==ITL_MSG_SEQ_1)) ) 
 208   2                          continue;
 209   2                      len = ITLMsgBuf[i+2];
 210   2                      if( i+len+5 > sizeof( ITLMsgBuf ) ) 
 211   2                          break;
 212   2      
 213   2              //-------------------------------------------------
 214   2                      /*
 215   2                      #ifdef ITL_DEBUG
 216   2                  return 1;
 217   2                      #endif
 218   2                      */
 219   2              //=================================================
 220   2      
 221   2                  //Delete the extral "0x7F"
 222   2                      memset( newMsg, 0, sizeof(newMsg) );
 223   2              position = i;
 224   2                      k = 0;
 225   2                      newMsg[k++] = ITLMsgBuf[i];
 226   2                      newMsg[k++] = ITLMsgBuf[i+1];
 227   2              for( j=i+2; j<sizeof(ITLMsgBuf); j++)
 228   2                      {
 229   3                      newMsg[k++] = ITLMsgBuf[j];
 230   3                              if( ITLMsgBuf[j+1] == ITL_MSG_STX )
 231   3                              {
 232   4                                      j += 1;
 233   4                              }
 234   3                      }
 235   2                      //Check the CHK
 236   2                      ITLResetCrc();
 237   2            //ITLUpdateCrc( newMsg[0] );
 238   2              ITLUpdateCrc( newMsg[1] );   //
 239   2                  ITLUpdateCrc( newMsg[2] );   //     
 240   2                  for( j=3; j<len+3; j++ )
 241   2                  {
CX51 COMPILER V7.50   ITL                                                                  10/23/2014 09:48:34 PAGE 5   

 242   3                      ITLUpdateCrc( newMsg[j] );
 243   3                  }
 244   2                      if( (sysITLMission.crcL != newMsg[j]) || (sysITLMission.crcH != newMsg[j+1]) )
 245   2                              continue;
 246   2                      //Check the message type
 247   2              if( !( (newMsg[2]>=1)&&((newMsg[3]>=ITL_ACK_MIN)&&(newMsg[3]<=ITL_ACK_MAX)) ) )   
 248   2                  continue;     
 249   2                      //Save the message
 250   2                      sysITLMission.receive.stx = newMsg[0];
 251   2                      sysITLMission.receive.seq = newMsg[1];
 252   2                      sysITLMission.receive.len = newMsg[2];
 253   2                      for( k=0,j=3; j<sysITLMission.receive.len+3; k++,j++ )
 254   2                      {
 255   3                              sysITLMission.receive.msg[k] = newMsg[j];       
 256   3                      }
 257   2              sysITLMission.receive.crcL = newMsg[j];
 258   2                      sysITLMission.receive.crcH = newMsg[j+1];
 259   2                      memset( ITLMsgBuf, 0, sizeof(ITLMsgBuf) );
 260   2                      return 1;
 261   2              }       
 262   1              return 0;
 263   1                              
 264   1      }
 265          
 266          //Create the CHK and send the message
 267          unsigned char ITLBusTxMsg( void )
 268          {
 269   1              unsigned char i = 0;
 270   1              //1.Create the CHK
 271   1          ITLResetCrc();
 272   1          ITLUpdateCrc( sysITLMission.send.seq );   //
 273   1              ITLUpdateCrc( sysITLMission.send.len ); 
 274   1              for( i=0; i<sysITLMission.send.len; i++ )
 275   1              {
 276   2              ITLUpdateCrc( sysITLMission.send.msg[i] );
 277   2              }
 278   1          //--------------------------------------------
 279   1          #ifdef ITL_DEBUG
                      if( (sysITLMission.send.msg[0]==ITL_CMD_SETINHIBITS)&&(sysITLMission.send.seq==0x80) )
                      {
                              sysITLMission.crcL = 0x25;
                          sysITLMission.crcH = 0xa4;  
                      }
                      else if( (sysITLMission.send.msg[0]==ITL_CMD_ENABLE)&&(sysITLMission.send.seq==0x00) )
                      {
                          sysITLMission.crcL = 0x3C;
                          sysITLMission.crcH = 0x08;
                      }
                      else if( (sysITLMission.send.msg[0]==ITL_CMD_POLL)&&(sysITLMission.send.seq==0x00) )
                      {
                          sysITLMission.crcL = 0x11;
                          sysITLMission.crcH = 0x88;
                      }
                      else if( (sysITLMission.send.msg[0]==ITL_CMD_POLL)&&(sysITLMission.send.seq==0x80) )
                      {
                          sysITLMission.crcL = 0x12;
                          sysITLMission.crcH = 0x02;
                      }
                  #endif
 301   1          //============================================
 302   1              sysITLMission.send.crcL = sysITLMission.crcL;
 303   1              sysITLMission.send.crcH = sysITLMission.crcH;
CX51 COMPILER V7.50   ITL                                                                  10/23/2014 09:48:34 PAGE 6   

 304   1              //2.Send the message
 305   1          ZhkSerial1PutCh( sysITLMission.send.stx );
 306   1              delay( ITL_COM_DELAY );
 307   1              ZhkSerial1PutCh( sysITLMission.send.seq );
 308   1          delay( ITL_COM_DELAY );
 309   1          ZhkSerial1PutCh( sysITLMission.send.len );
 310   1              delay( ITL_COM_DELAY );
 311   1              if( sysITLMission.send.len == ITL_MSG_STX )
 312   1              {
 313   2                      ZhkSerial1PutCh( sysITLMission.send.len );
 314   2                      delay( ITL_COM_DELAY );
 315   2              }
 316   1      
 317   1              for( i=0; i<sysITLMission.send.len; i++ )
 318   1              {
 319   2                      ZhkSerial1PutCh( sysITLMission.send.msg[i] );
 320   2                      delay( ITL_COM_DELAY );
 321   2                      if( sysITLMission.send.msg[i] == ITL_MSG_STX )
 322   2                      {
 323   3                              ZhkSerial1PutCh( sysITLMission.send.msg[i] );
 324   3                              delay( ITL_COM_DELAY );
 325   3                      }
 326   2              }
 327   1      
 328   1              ZhkSerial1PutCh( sysITLMission.send.crcL );
 329   1              delay( ITL_COM_DELAY );
 330   1              if( sysITLMission.send.crcL == ITL_MSG_STX )
 331   1              {
 332   2                  ZhkSerial1PutCh( sysITLMission.send.crcL );
 333   2                      delay( ITL_COM_DELAY );
 334   2              }
 335   1          
 336   1              ZhkSerial1PutCh( sysITLMission.send.crcH );
 337   1              delay( ITL_COM_DELAY );
 338   1              if( sysITLMission.send.crcH == ITL_MSG_STX )
 339   1              {
 340   2                  ZhkSerial1PutCh( sysITLMission.send.crcH );
 341   2                      delay( ITL_COM_DELAY );
 342   2              }
 343   1          
 344   1          return 1;
 345   1      }
 346          
 347          //msgType, seq 
 348          unsigned char ITLMsgPackSend( unsigned char msgType, unsigned char flag )
 349          {
 350   1      
 351   1          unsigned char i = 0;
 352   1      
 353   1          if( !((msgType>=ITL_CMD_MIN)&&(msgType<=ITL_CMD_MAX)) )
 354   1                      return ITL_ERR_PAR;
 355   1      
 356   1          if( !((flag>=0)&&(flag<=1)) )
 357   1                  return ITL_ERR_PAR;
 358   1      
 359   1              sysITLMission.send.stx = ITL_MSG_STX;
 360   1              if( flag == 1 )
 361   1              {
 362   2                      if( sysITLMission.send.seq == ITL_MSG_SEQ_0 )
 363   2                          sysITLMission.send.seq = ITL_MSG_SEQ_1;
 364   2                      else 
 365   2                          sysITLMission.send.seq = ITL_MSG_SEQ_0;
CX51 COMPILER V7.50   ITL                                                                  10/23/2014 09:48:34 PAGE 7   

 366   2              }
 367   1      
 368   1          switch( msgType )
 369   1              {
 370   2                  case ITL_CMD_RESET:
 371   2                              {
 372   3                                      sysITLMission.send.len = 1;
 373   3                                      sysITLMission.send.msg[0] = ITL_CMD_RESET;
 374   3                              }
 375   2                              break;
 376   2                      case ITL_CMD_SETINHIBITS:
 377   2                          {
 378   3                                  sysITLMission.send.len = 3;
 379   3                                      sysITLMission.send.msg[0] = ITL_CMD_SETINHIBITS;
 380   3                                      sysITLMission.send.msg[1] = sysITLMission.chnCtr1;
 381   3                                      sysITLMission.send.msg[2] = sysITLMission.chnCtr2;
 382   3                              }
 383   2                          break;
 384   2              case ITL_CMD_DSPON:
 385   2                          {
 386   3                                  sysITLMission.send.len = 1;
 387   3                                      sysITLMission.send.msg[0] = ITL_CMD_DSPON;
 388   3                              }
 389   2                          break;
 390   2                      case ITL_CMD_DSPOFF:
 391   2                          {
 392   3                                  sysITLMission.send.len = 1;
 393   3                                      sysITLMission.send.msg[0] = ITL_CMD_DSPOFF;
 394   3                              }
 395   2                          break;
 396   2                      case ITL_CMD_SETUP:
 397   2                          {
 398   3                                   sysITLMission.send.len = 1;
 399   3                                       sysITLMission.send.msg[0] = ITL_CMD_SETUP;
 400   3                              }
 401   2                          break;
 402   2                      case ITL_CMD_POLL:
 403   2                          {
 404   3                                   sysITLMission.send.len = 1;
 405   3                                       sysITLMission.send.msg[0] = ITL_CMD_POLL;
 406   3                              }
 407   2                          break;
 408   2                      case ITL_CMD_REJECT:
 409   2                          {
 410   3                                   sysITLMission.send.len = 1;
 411   3                                       sysITLMission.send.msg[0] = ITL_CMD_REJECT;
 412   3                              }
 413   2                          break;
 414   2                      case ITL_CMD_DISABLE:
 415   2                          {
 416   3                                   sysITLMission.send.len = 1;
 417   3                                       sysITLMission.send.msg[0] = ITL_CMD_DISABLE;
 418   3                              }
 419   2                          break;
 420   2              case ITL_CMD_ENABLE:
 421   2                          {
 422   3                                       sysITLMission.send.len = 1;
 423   3                                       sysITLMission.send.msg[0] = ITL_CMD_ENABLE;
 424   3                              }
 425   2                          break;
 426   2                      case ITL_CMD_SYN:
 427   2                          {
CX51 COMPILER V7.50   ITL                                                                  10/23/2014 09:48:34 PAGE 8   

 428   3                                   sysITLMission.send.len = 1;
 429   3                                       sysITLMission.send.msg[0] = ITL_CMD_SYN;
 430   3                              }
 431   2                          break;
 432   2              case ITL_CMD_HOLD:
 433   2                          {
 434   3                                   sysITLMission.send.len = 1;
 435   3                                       sysITLMission.send.msg[0] = ITL_CMD_HOLD;
 436   3                              }
 437   2                          break;
 438   2                      default: break;
 439   2              }
 440   1          ITLBusTxMsg();
 441   1          DelayMs(10);
 442   1          return ITL_ERR_NULL;
 443   1      }
 444          
 445          unsigned char ITLMission_Syn( void )
 446          {    
 447   1          unsigned char retry = 0;
 448   1              unsigned char i = 0;
 449   1              unsigned char flag = 0;
 450   1          
 451   1              //1.
 452   1          ITLSerialInit();
 453   1              //2.
 454   1          retry = ITL_COM_RETRY;
 455   1      TAB_ITLM_Syn_RETRY:
 456   1              flag = ITLMsgPackSend( ITL_CMD_SYN, 1);
 457   1          if( flag != ITL_ERR_NULL )
 458   1          {
 459   2                      return ITL_ERR_PAR;
 460   2              }
 461   1              sysITLMission.msTimer2 = ITL_TIME_OUT;
 462   1              while( sysITLMission.msTimer2 )
 463   1              {
 464   2                      if( ITLBusUnpack() )
 465   2                      {
 466   3                          sysITLMission.comErrNum = 0;
 467   3                              goto TAB_ITLM_Syn_COM_OK;
 468   3                      }
 469   2              }
 470   1              if( retry-- )
 471   1              {
 472   2                      goto TAB_ITLM_Syn_RETRY;
 473   2              }
 474   1              else
 475   1              {
 476   2                      sysITLMission.comErrNum++;
 477   2              return ITL_ERR_COM;
 478   2              }
 479   1      TAB_ITLM_Syn_COM_OK:
 480   1          sysITLMission.billESta = sysITLMission.receive.msg[0];
 481   1          return ITL_ERR_NULL;
 482   1      
 483   1      }
 484          
 485          
 486          unsigned char ITLMission_Setup( void )
 487          {    
 488   1          unsigned char retry = 0;
 489   1              unsigned char i = 0;
CX51 COMPILER V7.50   ITL                                                                  10/23/2014 09:48:34 PAGE 9   

 490   1              unsigned char flag = 0;
 491   1          
 492   1              //1.
 493   1          ITLSerialInit();
 494   1              //2.
 495   1          retry = ITL_COM_RETRY;
 496   1      TAB_ITLM_Setup_RETRY:
 497   1              flag = ITLMsgPackSend( ITL_CMD_SETUP, 1);
 498   1          if( flag != ITL_ERR_NULL )
 499   1          {
 500   2                      return ITL_ERR_PAR;
 501   2              }
 502   1              sysITLMission.msTimer2 = ITL_TIME_OUT;
 503   1              while( sysITLMission.msTimer2 )
 504   1              {
 505   2                      if( ITLBusUnpack() )
 506   2                      {
 507   3                          sysITLMission.comErrNum = 0;
 508   3                              goto TAB_ITLM_Setup_COM_OK;
 509   3                      }
 510   2              }
 511   1              if( retry-- )
 512   1              {
 513   2                      goto TAB_ITLM_Setup_RETRY;
 514   2              }
 515   1              else
 516   1              {
 517   2                      sysITLMission.comErrNum++;
 518   2              return ITL_ERR_COM;
 519   2              }
 520   1      TAB_ITLM_Setup_COM_OK:
 521   1          sysITLMission.billESta = sysITLMission.receive.msg[0];
 522   1          return ITL_ERR_NULL;
 523   1      
 524   1      }
 525          
 526          unsigned char ITLMission_SetInhibit( void )
 527          {    
 528   1          unsigned char retry = 0;
 529   1              unsigned char i = 0;
 530   1              unsigned char flag = 0;
 531   1        
 532   1              //1.
 533   1          ITLSerialInit();
 534   1              //2.
 535   1          ITLChnCtr();
 536   1          retry = ITL_COM_RETRY;
 537   1      TAB_ITLM_SetInhibit_RETRY:
 538   1              flag = ITLMsgPackSend( ITL_CMD_SETINHIBITS, 1);
 539   1          if( flag != ITL_ERR_NULL )
 540   1          {
 541   2                      return ITL_ERR_PAR;
 542   2              }
 543   1              sysITLMission.msTimer2 = ITL_TIME_OUT;
 544   1              while( sysITLMission.msTimer2 )
 545   1              {
 546   2                      if( ITLBusUnpack() )
 547   2                      {
 548   3                          sysITLMission.comErrNum = 0;
 549   3                              goto TAB_ITLM_SetInhibit_COM_OK;
 550   3                      }
 551   2              }
CX51 COMPILER V7.50   ITL                                                                  10/23/2014 09:48:34 PAGE 10  

 552   1              if( retry-- )
 553   1              {
 554   2                      goto TAB_ITLM_SetInhibit_RETRY;
 555   2              }
 556   1              else
 557   1              {
 558   2                      sysITLMission.comErrNum++;
 559   2              return ITL_ERR_COM;
 560   2              }
 561   1      TAB_ITLM_SetInhibit_COM_OK:
 562   1          sysITLMission.billESta = sysITLMission.receive.msg[0];
 563   1          return ITL_ERR_NULL;
 564   1      
 565   1      }
 566          
 567          unsigned char ITLMission_Reset( void )
 568          {    
 569   1          unsigned char retry = 0;
 570   1              unsigned char i = 0;
 571   1              unsigned char flag = 0;
 572   1      
 573   1              //1.
 574   1          ITLSerialInit();
 575   1              //2.
 576   1          retry = ITL_COM_RETRY;
 577   1      TAB_ITLM_Reset_RETRY:
 578   1              flag = ITLMsgPackSend( ITL_CMD_RESET, 1);
 579   1          if( flag != ITL_ERR_NULL )
 580   1          {
 581   2                      return ITL_ERR_PAR;
 582   2              }
 583   1              sysITLMission.msTimer2 = ITL_TIME_OUT;
 584   1              while( sysITLMission.msTimer2 )
 585   1              {
 586   2                      if( ITLBusUnpack() )
 587   2                      {
 588   3                          sysITLMission.comErrNum = 0;
 589   3                              goto TAB_ITLM_Reset_COM_OK;
 590   3                      }
 591   2              }
 592   1              if( retry-- )
 593   1              {
 594   2                      goto TAB_ITLM_Reset_RETRY;
 595   2              }
 596   1              else
 597   1              {
 598   2                      sysITLMission.comErrNum++;
 599   2              return ITL_ERR_COM;
 600   2              }
 601   1      TAB_ITLM_Reset_COM_OK:
 602   1          sysITLMission.billESta = sysITLMission.receive.msg[0];
 603   1          return ITL_ERR_NULL;
 604   1      
 605   1      }
 606          
 607          unsigned char ITLMission_Dspon( void )
 608          {    
 609   1          unsigned char retry = 0;
 610   1              unsigned char i = 0;
 611   1              unsigned char flag = 0;
 612   1      
 613   1              //1.
CX51 COMPILER V7.50   ITL                                                                  10/23/2014 09:48:34 PAGE 11  

 614   1          ITLSerialInit();
 615   1              //2.
 616   1          retry = ITL_COM_RETRY;
 617   1      TAB_ITLM_Dspon_RETRY:
 618   1              flag = ITLMsgPackSend( ITL_CMD_DSPON, 1);
 619   1          if( flag != ITL_ERR_NULL )
 620   1          {
 621   2                      return ITL_ERR_PAR;
 622   2              }
 623   1              sysITLMission.msTimer2 = ITL_TIME_OUT;
 624   1              while( sysITLMission.msTimer2 )
 625   1              {
 626   2                      if( ITLBusUnpack() )
 627   2                      {
 628   3                          sysITLMission.comErrNum = 0;
 629   3                              goto TAB_ITLM_Dspon_COM_OK;
 630   3                      }
 631   2              }
 632   1              if( retry-- )
 633   1              {
 634   2                      goto TAB_ITLM_Dspon_RETRY;
 635   2              }
 636   1              else
 637   1              {
 638   2                      sysITLMission.comErrNum++;
 639   2              return ITL_ERR_COM;
 640   2              }
 641   1      TAB_ITLM_Dspon_COM_OK:
 642   1          sysITLMission.billESta = sysITLMission.receive.msg[0];
 643   1          return ITL_ERR_NULL;
 644   1      
 645   1      }
 646          
 647          unsigned char ITLMission_Dspoff( void )
 648          {    
 649   1          unsigned char retry = 0;
 650   1              unsigned char i = 0;
 651   1              unsigned char flag = 0;
 652   1      
 653   1              //1.
 654   1          ITLSerialInit();
 655   1              //2.
 656   1          retry = ITL_COM_RETRY;
 657   1      TAB_ITLM_Dspoff_RETRY:
 658   1              flag = ITLMsgPackSend( ITL_CMD_DSPOFF, 1);
 659   1          if( flag != ITL_ERR_NULL )
 660   1          {
 661   2                      return ITL_ERR_PAR;
 662   2              }
 663   1              sysITLMission.msTimer2 = ITL_TIME_OUT;
 664   1              while( sysITLMission.msTimer2 )
 665   1              {
 666   2                      if( ITLBusUnpack() )
 667   2                      {
 668   3                          sysITLMission.comErrNum = 0;
 669   3                              goto TAB_ITLM_Dspoff_COM_OK;
 670   3                      }
 671   2              }
 672   1              if( retry-- )
 673   1              {
 674   2                      goto TAB_ITLM_Dspoff_RETRY;
 675   2              }
CX51 COMPILER V7.50   ITL                                                                  10/23/2014 09:48:34 PAGE 12  

 676   1              else
 677   1              {
 678   2                      sysITLMission.comErrNum++;
 679   2              return ITL_ERR_COM;
 680   2              }
 681   1      TAB_ITLM_Dspoff_COM_OK:
 682   1          sysITLMission.billESta = sysITLMission.receive.msg[0];
 683   1          return ITL_ERR_NULL;
 684   1      
 685   1      }
 686          
 687          unsigned char ITLMission_Hold( void )
 688          {    
 689   1          unsigned char retry = 0;
 690   1              unsigned char i = 0;
 691   1              unsigned char flag = 0;
 692   1      
 693   1              //1.
 694   1          ITLSerialInit();
 695   1              //2.
 696   1          retry = ITL_COM_RETRY;
 697   1      TAB_ITLM_Hold_RETRY:
 698   1              flag = ITLMsgPackSend( ITL_CMD_HOLD, 1);
 699   1          if( flag != ITL_ERR_NULL )
 700   1          {
 701   2                      return ITL_ERR_PAR;
 702   2              }
 703   1              sysITLMission.msTimer2 = ITL_TIME_OUT;
 704   1              while( sysITLMission.msTimer2 )
 705   1              {
 706   2                      if( ITLBusUnpack() )
 707   2                      {
 708   3                          sysITLMission.comErrNum = 0;
 709   3                              goto TAB_ITLM_Hold_COM_OK;
 710   3                      }
 711   2              }
 712   1              if( retry-- )
 713   1              {
 714   2                      goto TAB_ITLM_Hold_RETRY;
 715   2              }
 716   1              else
 717   1              {
 718   2                      sysITLMission.comErrNum++;
 719   2              return ITL_ERR_COM;
 720   2              }
 721   1      TAB_ITLM_Hold_COM_OK:
 722   1          sysITLMission.billESta = sysITLMission.receive.msg[0];
 723   1          return ITL_ERR_NULL;
 724   1      
 725   1      }
 726          
 727          
 728          unsigned char ITLMission_Enable( void )
 729          {    
 730   1          unsigned char retry = 0;
 731   1              unsigned char i = 0;
 732   1              unsigned char flag = 0;
 733   1        
 734   1              //1.
 735   1          ITLSerialInit();
 736   1              //2.
 737   1          retry = ITL_COM_RETRY;
CX51 COMPILER V7.50   ITL                                                                  10/23/2014 09:48:34 PAGE 13  

 738   1      TAB_ITLM_Enable_RETRY:
 739   1              flag = ITLMsgPackSend( ITL_CMD_ENABLE, 1);
 740   1          if( flag != ITL_ERR_NULL )
 741   1          {
 742   2                      return ITL_ERR_PAR;
 743   2              }
 744   1              sysITLMission.msTimer2 = ITL_TIME_OUT;
 745   1              while( sysITLMission.msTimer2 )
 746   1              {
 747   2                      if( ITLBusUnpack() )
 748   2                      {
 749   3                          sysITLMission.comErrNum = 0;
 750   3                              goto TAB_ITLM_Enable_COM_OK;
 751   3                      }
 752   2              }
 753   1              if( retry-- )
 754   1              {
 755   2                      goto TAB_ITLM_Enable_RETRY;
 756   2              }
 757   1              else
 758   1              {
 759   2                      sysITLMission.comErrNum++;
 760   2              return ITL_ERR_COM;
 761   2              }
 762   1      TAB_ITLM_Enable_COM_OK:
 763   1          sysITLMission.enableFlag = 1;
 764   1              sysITLMission.billESta = sysITLMission.receive.msg[0];
 765   1          return ITL_ERR_NULL;
 766   1      
 767   1      }
 768          
 769          unsigned char ITLMission_Disable( void )
 770          {    
 771   1          /*
 772   1          unsigned char retry = 0;
 773   1              unsigned char i = 0;
 774   1              unsigned char flag = 0;
 775   1      
 776   1          
 777   1              //1.
 778   1          ITLSerialInit();
 779   1              //2.
 780   1          retry = ITL_COM_RETRY;
 781   1      TAB_ITLM_Disable_RETRY:
 782   1              flag = ITLMsgPackSend( ITL_CMD_DISABLE, 1);
 783   1          if( flag != ITL_ERR_NULL )
 784   1          {
 785   1                      return ITL_ERR_PAR;
 786   1              }
 787   1              sysITLMission.msTimer2 = ITL_TIME_OUT;
 788   1              while( sysITLMission.msTimer2 )
 789   1              {
 790   1                      if( ITLBusUnpack() )
 791   1                      {
 792   1                          sysITLMission.comErrNum = 0;
 793   1                              goto TAB_ITLM_Disable_COM_OK;
 794   1                      }
 795   1              }
 796   1              if( retry-- )
 797   1              {
 798   1                      goto TAB_ITLM_Disable_RETRY;
 799   1              }
CX51 COMPILER V7.50   ITL                                                                  10/23/2014 09:48:34 PAGE 14  

 800   1              else
 801   1              {
 802   1                      sysITLMission.comErrNum++;
 803   1              return ITL_ERR_COM;
 804   1              }
 805   1      TAB_ITLM_Disable_COM_OK:
 806   1          sysITLMission.enableFlag = 0;
 807   1              sysITLMission.billESta = sysITLMission.receive.msg[0];
 808   1          return ITL_ERR_NULL;
 809   1         */
 810   1         return ITL_ERR_NULL;
 811   1      }
 812          
 813          unsigned char ITLMission_Reject( void )
 814          {    
 815   1          /*
 816   1          unsigned char retry = 0;
 817   1              unsigned char i = 0;
 818   1              unsigned char flag = 0;
 819   1      
 820   1              //1.
 821   1          ITLSerialInit();
 822   1              //2.
 823   1          retry = ITL_COM_RETRY;
 824   1      TAB_ITLM_Reject_RETRY:
 825   1              flag = ITLMsgPackSend( ITL_CMD_REJECT, 1);
 826   1          if( flag != ITL_ERR_NULL )
 827   1          {
 828   1                      return ITL_ERR_PAR;
 829   1              }
 830   1              sysITLMission.msTimer2 = ITL_TIME_OUT;
 831   1              while( sysITLMission.msTimer2 )
 832   1              {
 833   1                      if( ITLBusUnpack() )
 834   1                      {
 835   1                          sysITLMission.comErrNum = 0;
 836   1                              goto TAB_ITLM_Reject_COM_OK;
 837   1                      }
 838   1              }
 839   1              if( retry-- )
 840   1              {
 841   1                      goto TAB_ITLM_Reject_RETRY;
 842   1              }
 843   1              else
 844   1              {
 845   1                      sysITLMission.comErrNum++;
 846   1              return ITL_ERR_COM;
 847   1              }
 848   1      TAB_ITLM_Reject_COM_OK:
 849   1          sysITLMission.billESta = sysITLMission.receive.msg[0];
 850   1          return ITL_ERR_NULL;
 851   1              */
 852   1              return ITL_ERR_NULL;
 853   1      
 854   1      }
 855          
 856          
 857          unsigned char ITLMission_Poll( void )
 858          {   
 859   1          /* 
 860   1          unsigned char retry = 0;
 861   1              unsigned char i = 0;
CX51 COMPILER V7.50   ITL                                                                  10/23/2014 09:48:34 PAGE 15  

 862   1              unsigned char flag = 0;
 863   1          
 864   1              //1.
 865   1          ITLSerialInit();
 866   1              //2.
 867   1          retry = ITL_COM_RETRY;
 868   1      TAB_ITLM_P_RETRY:
 869   1              flag = ITLMsgPackSend( ITL_CMD_POLL, 1);
 870   1          if( flag != ITL_ERR_NULL )
 871   1          {
 872   1                      return ITL_ERR_PAR;
 873   1              }
 874   1              sysITLMission.msTimer2 = ITL_TIME_OUT;
 875   1              while( sysITLMission.msTimer2 )   //sysVPMission.msTimer2
 876   1              {
 877   1                      if( ITLBusUnpack() )
 878   1                      {
 879   1                          sysITLMission.comErrNum = 0;
 880   1                              goto TAB_ITLM_P_COM_OK;
 881   1                      }
 882   1              //------------------------------------------------------------------
 883   1              if( IfGameKeyOn() )
 884   1                      {
 885   1                              VPMission_Button_RPT( VP_BUT_GAME, VP_BUT_NUMBER );
 886   1                      //Beep();
 887   1                      }
 888   1              //===================================================================
 889   1              }
 890   1      
 891   1              if( retry-- )
 892   1              {
 893   1                      goto TAB_ITLM_P_RETRY;
 894   1              }
 895   1              else
 896   1              {
 897   1                      sysITLMission.comErrNum++;
 898   1                      if( sysITLMission.comErrNum >= ITL_TIME_OUT_NUM )
 899   1                      {
 900   1                              DeviceStatus.BillAccepter |= 0x01;
 901   1                      }
 902   1              return ITL_ERR_COM;
 903   1              }
 904   1      TAB_ITLM_P_COM_OK:
 905   1          //Check the the bill status
 906   1              sysITLMission.billSta  = ITL_BILL_NULL;
 907   1          sysITLMission.billESta = ITL_BILL_NULL;
 908   1              sysITLMission.status   = ITL_DEV_NULL;
 909   1          for( i=0; i<sysITLMission.receive.len; i++ )
 910   1              {
 911   1                      if( sysITLMission.receive.msg[i] == ITL_ACK_READ )
 912   1                      {
 913   1                              if( (sysITLMission.receive.msg[i+1]>=1)&&(sysITLMission.receive.msg[i+1]<=8) )
 914   1                              {
 915   1                                      sysITLMission.billSta  |= ITL_BILL_READ;
 916   1                                      sysITLMission.billChn   = sysITLMission.receive.msg[i+1];
 917   1                                      sysITLMission.billValue = SystemParameter.billValue[sysITLMission.billChn-1];
 918   1                              }
 919   1                      }
 920   1                      else if( sysITLMission.receive.msg[i] == ITL_ACK_STACKING )
 921   1                      {
 922   1                              sysITLMission.billSta |= ITL_BILL_STACKING;
 923   1                      }
CX51 COMPILER V7.50   ITL                                                                  10/23/2014 09:48:34 PAGE 16  

 924   1                      else if( sysITLMission.receive.msg[i] == ITL_ACK_CREDIT )
 925   1                      {
 926   1                              if( (sysITLMission.receive.msg[i+1]>=1)&&(sysITLMission.receive.msg[i+1]<=8) )
 927   1                              {
 928   1                                      sysITLMission.billSta  |= ITL_BILL_CREDIT;
 929   1                                      sysITLMission.billChn   = sysITLMission.receive.msg[i+1];
 930   1                                      sysITLMission.billValue = SystemParameter.billValue[sysITLMission.billChn-1];
 931   1                              }
 932   1                      }
 933   1                      else if( sysITLMission.receive.msg[i] == ITL_ACK_STACKED )
 934   1                      {
 935   1                              sysITLMission.billSta  |= ITL_BILL_STACKED;
 936   1                      }
 937   1              else if( sysITLMission.receive.msg[i] == ITL_ACK_REJECTING )
 938   1                      {
 939   1                              sysITLMission.billSta  |= ITL_BILL_REJECTING;
 940   1                      }
 941   1                      else if( sysITLMission.receive.msg[i] == ITL_ACK_REJECTED )
 942   1                      {
 943   1                              sysITLMission.billSta  |= ITL_BILL_REJECTED;
 944   1                      }
 945   1                      else if( sysITLMission.receive.msg[i] == ITL_ACK_SJAM )
 946   1                      {
 947   1                              sysITLMission.billSta  |= ITL_BILL_SJAM;   //ERR
 948   1                      }
 949   1              else if( sysITLMission.receive.msg[i] == ITL_ACK_UJAM )
 950   1                      {
 951   1                              sysITLMission.billSta  |= ITL_BILL_UJAM;  //ERR
 952   1                      }
 953   1                      //
 954   1                      else if( sysITLMission.receive.msg[i] == ITL_ACK_RESET )
 955   1                      {
 956   1                          sysITLMission.status |= ITL_DEV_RESET;
 957   1                      }
 958   1                      else if( sysITLMission.receive.msg[i] == ITL_ACK_DISABLED )
 959   1                      {
 960   1                          sysITLMission.status |= ITL_DEV_DISABLED;
 961   1                      }
 962   1              else if( sysITLMission.receive.msg[i] == ITL_ACK_NCFFAR )
 963   1                      {
 964   1                          sysITLMission.status |= ITL_DEV_NCFFAR;
 965   1                      }
 966   1              else if( sysITLMission.receive.msg[i] == ITL_ACK_NCICBAR )
 967   1                      {
 968   1                          sysITLMission.status |= ITL_DEV_NCICBAR;
 969   1                      }
 970   1              else if( sysITLMission.receive.msg[i] == ITL_ACK_CBREM )
 971   1                      {
 972   1                          sysITLMission.status |= ITL_DEV_CBREM;
 973   1                      }
 974   1              else if( sysITLMission.receive.msg[i] == ITL_ACK_CBREP )
 975   1                      {
 976   1                          sysITLMission.status |= ITL_DEV_CBREP;
 977   1                      }
 978   1                      else if( sysITLMission.receive.msg[i] == ITL_ACK_STAFULL )
 979   1                      {
 980   1                          sysITLMission.status |= ITL_DEV_STAFULL;
 981   1                      }
 982   1                      else if( sysITLMission.receive.msg[i] == ITL_ACK_FATTN )
 983   1                      {
 984   1                          sysITLMission.status |= ITL_DEV_FATTN;
 985   1                      }
CX51 COMPILER V7.50   ITL                                                                  10/23/2014 09:48:34 PAGE 17  

 986   1              else if( sysITLMission.receive.msg[i] == ITL_ACK_FAIL )
 987   1                      {
 988   1                          sysITLMission.status |= ITL_DEV_FAIL;
 989   1                      }
 990   1              //Andy added 2011.4.15.
 991   1              else if( sysITLMission.receive.msg[i] == ITL_ACK_CMDAPL )
 992   1              {
 993   1                      sysITLMission.billESta = ITL_ACK_CMDAPL;
 994   1              }
 995   1              else if( sysITLMission.receive.msg[i] == ITL_ACK_OK )
 996   1              {
 997   1                      sysITLMission.billESta = ITL_ACK_OK;
 998   1              }
 999   1      
1000   1              } 
1001   1          return ITL_ERR_NULL;
1002   1              */
1003   1              return ITL_ERR_NULL;
1004   1      }
1005          
1006          unsigned char ITLMission_Init_1( void )
1007          {
1008   1          /*
1009   1          //ITLMission_Reset();
1010   1          //DelayMs( ITL_TIME_CMD_INTEVEL );          
1011   1          //ITLMission_Syn();
1012   1          //DelayMs( ITL_TIME_CMD_INTEVEL );
1013   1          ITLMission_Disable();
1014   1          DelayMs( ITL_TIME_CMD_INTEVEL_1 );
1015   1          ITLMission_SetInhibit();
1016   1          DelayMs( ITL_TIME_CMD_INTEVEL_1 );
1017   1          ITLMission_Dspon();
1018   1          DelayMs( ITL_TIME_CMD_INTEVEL_1 );
1019   1              ITLMission_Enable();
1020   1          DelayMs( ITL_TIME_CMD_INTEVEL_1 );
1021   1          return ITL_ERR_NULL;
1022   1              */
1023   1              //MDBMission_Bill_Init();
1024   1          return ITL_ERR_NULL;
1025   1      }
1026          
1027          unsigned char ITLMission_Init( void )
1028          {
1029   1          /* 
1030   1          ITLMission_Reset();
1031   1          DelayMs( ITL_TIME_CMD_INTEVEL );          //30000,10000,4000,3000
1032   1          //ITLMission_Syn();
1033   1          //DelayMs( ITL_TIME_CMD_INTEVEL );
1034   1          ITLMission_SetInhibit();
1035   1          DelayMs( ITL_TIME_CMD_INTEVEL );
1036   1          ITLMission_Dspon();
1037   1          DelayMs( ITL_TIME_CMD_INTEVEL );
1038   1              ITLMission_Enable();
1039   1          DelayMs( ITL_TIME_CMD_INTEVEL );
1040   1          return ITL_ERR_NULL;
1041   1              */
1042   1              //MDBMission_Bill_Init();
1043   1          return ITL_ERR_NULL;
1044   1      }
1045          
1046          unsigned char ITLMission_HB_Stack( void )
1047          {
CX51 COMPILER V7.50   ITL                                                                  10/23/2014 09:48:34 PAGE 18  

1048   1          unsigned char flag = 0;
1049   1              if( sysITLMission.billHoldingFlag == 1 )
1050   1              {
1051   2                  flag = ITLMission_Poll(); 
1052   2              sysITLMission.msPoll = ITL_TIME_POLL;
1053   2                      sysITLMission.sTimer2 = ITL_TIME_STACK;
1054   2                      while( sysITLMission.sTimer2 )
1055   2                      {
1056   3      
1057   3                          if( sysITLMission.billSta & ITL_BILL_STACKED )
1058   3                              {
1059   4                                      sysITLMission.billStaCtr |= ITL_BILL_STACKED;
1060   4                      sysITLMission.billSta &= ~ITL_BILL_STACKED;
1061   4                              }
1062   3      
1063   3                  if( sysITLMission.billSta & ITL_BILL_CREDIT )
1064   3                              {
1065   4                                      sysITLMission.billStaCtr |= ITL_BILL_CREDIT;
1066   4                                      sysITLMission.billSta &= ~ITL_BILL_CREDIT;
1067   4                              }
1068   3      
1069   3                          //if( ( sysITLMission.billSta & ITL_BILL_STACKED ) )
1070   3                          //if( ( sysITLMission.billSta & ITL_BILL_CREDIT )&&( sysITLMission.billStaCtr&ITL_BILL_READ ) )
1071   3                              //if( ( sysITLMission.billSta & ITL_BILL_CREDIT )&&( sysITLMission.billSta&ITL_BILL_STACKED )&&( sysITL
             -Mission.billStaCtr&ITL_BILL_READ ) )
1072   3                              if( ( sysITLMission.billStaCtr&ITL_BILL_CREDIT )&&( sysITLMission.billStaCtr&ITL_BILL_STACKED )&&( sysI
             -TLMission.billStaCtr&ITL_BILL_READ ) )
1073   3                      {    
1074   4                                  sysITLMission.billStaCtr &= ~ITL_BILL_READ;
1075   4                                  sysITLMission.billStaCtr &= ~ITL_BILL_CREDIT;
1076   4                      sysITLMission.billStaCtr &= ~ITL_BILL_STACKED;
1077   4                                      break;
1078   4                              }
1079   3                  else if( sysITLMission.msPoll == 0 )
1080   3                              {
1081   4                                      flag = ITLMission_Poll(); 
1082   4                              sysITLMission.msPoll = ITL_TIME_POLL;
1083   4                              }
1084   3                      }
1085   2              //Stack fail
1086   2                      if( sysITLMission.sTimer2 == 0 )
1087   2                      {
1088   3                              return 1;
1089   3                      }
1090   2              }
1091   1              return ITL_ERR_NULL;
1092   1      }
1093          
1094          
1095          
1096          unsigned char ITLMission_HB_Reject( void )
1097          {
1098   1          unsigned char flag = 0;
1099   1          if( sysITLMission.billHoldingFlag == 1 )
1100   1              {
1101   2              if( SystemParameter.RefundPermission==1 )
1102   2                      {
1103   3                              flag = ITLMission_Reject();
1104   3                              sysITLMission.msPoll = ITL_TIME_POLL;
1105   3                              sysITLMission.sTimer2 = ITL_TIME_REJECT;
1106   3                              while( sysITLMission.sTimer2 )
1107   3                              {
CX51 COMPILER V7.50   ITL                                                                  10/23/2014 09:48:34 PAGE 19  

1108   4                                      if( ( sysITLMission.billSta & ITL_BILL_REJECTED ))
1109   4                                      {
1110   5                                          sysITLMission.billSta &= ~ITL_BILL_REJECTED;
1111   5                                              //...
1112   5                                              break;
1113   5                                      }
1114   4                          else if( sysITLMission.msPoll == 0 )
1115   4                                      {
1116   5                                              flag = ITLMission_Reject(); 
1117   5                                      sysITLMission.msPoll = ITL_TIME_POLL;
1118   5                                      }
1119   4      
1120   4                              }
1121   3                              //
1122   3                              if( sysITLMission.sTimer2 == 0 )
1123   3                              {
1124   4                                      return 1;
1125   4                              }
1126   3                      }
1127   2              }
1128   1              return ITL_ERR_NULL;
1129   1      }
1130          
1131          
1132          
1133          
1134          
1135          /*****************************************************************************
1136          *****************************************************************************
1137          ***********************************MDB*********************************
1138          *****************************************************************************
1139          *****************************************************************************/
1140          
1141          
1142          
1143          void MDBSerialInit( void )
1144          {       
1145   1              unsigned char data i=0;
1146   1      
1147   1              for( i=0; i<sizeof( SERAIL1PARAM ); i ++ )
1148   1              {
1149   2                      ZhkSerial1Param[ i ] = ITLSerialParam[ i ];
1150   2              } 
1151   1              DelayMs(10);
1152   1              ZhkSerial1_MDB_Init();
1153   1              DelayMs(10);
1154   1          
1155   1          DelayMs(2);
1156   1              ZhkHardSerialSwitch( 0 );
1157   1              DelayMs(2);
1158   1      
1159   1          //memset( ITLMsgBuf, 0, sizeof(ITLMsgBuf) );   
1160   1      }
1161          
1162          
1163          /*****************************************************************************
1164          *UART
1165          *:add-VMC,dat[]-VMC,count-
1166          *:0-ACK,00x80-,0x80-
1167          *****************************************************************************/
1168          uchar Session(uchar add,uchar const dat[ ],uchar count)
1169          {
CX51 COMPILER V7.50   ITL                                                                  10/23/2014 09:48:34 PAGE 20  

1170   1              uchar check,i,j,err;
1171   1              uchar mode;
1172   1              
1173   1              sysMDBMission.port0_counter=0;
1174   1              for(j=0;j<5;j++)                      //5
1175   1              {
1176   2                check=0;
1177   2                err=0;
1178   2                ZhkSerial1_MDB_PutCh(add,1);                //
1179   2                check +=add;                        //CHK
1180   2                for(i=0;i<count;i++)                //
1181   2                {
1182   3                  ZhkSerial1_MDB_PutCh(dat[i],0);
1183   3                  check +=dat[i];
1184   3                }
1185   2                ZhkSerial1_MDB_PutCh(check,0);              //CHK
1186   2              
1187   2                for(i=0,check=0,mode=0;!mode && i<MDB_MAX_BLOCK_SIZF && !err;i++)  //   1
1188   2                {
1189   3                  //while( !ZhkSerial1IsRxBufNull() )
1190   3                      {
1191   4                          if(!ZhkSerial1_MDB_GetCh(&sysMDBMission.buff[i],&mode))  //,NAK
1192   4                            //err=i?MDB_ERR_TIME_OUT:MDB_NAK;
1193   4                    err=MDB_ERR_TIME_OUT;  //2011.7.9 changed for 0x80 error code
1194   4                          else if (i==0 && sysMDBMission.buff[i]==MDB_NAK && mode)  //NAK
1195   4                            err = MDB_NAK;
1196   4                          else if (!mode)          //0
1197   4                            check +=sysMDBMission.buff[i];
1198   4                      }
1199   3                } 
1200   2                if(!err)                            //
1201   2                {
1202   3                  if(!mode)                         //36
1203   3                  {
1204   4                    ZhkSerial1_MDB_PutCh(MDB_NAK,0);
1205   4                    err=MDB_ERR_NO_MODE_BIT;
1206   4                  }
1207   3                  else if (i>1)                   //
1208   3                  {
1209   4                    if(check !=sysMDBMission.buff[i-1])         //
1210   4                    {
1211   5                        ZhkSerial1_MDB_PutCh(MDB_NAK,0);
1212   5                        err=MDB_ERR_CHECKSUM;
1213   5                    }
1214   4                    else                        //ACK
1215   4                    {
1216   5                        ZhkSerial1_MDB_PutCh(MDB_ACK,0);
1217   5                        break;
1218   5                    }
1219   4                  }
1220   3                  else                          //ACK
1221   3                        break;
1222   3                }
1223   2              //  Wait(T_RESPONSE);                   //
1224   2              }
1225   1              sysMDBMission.port0_counter=err?err:(i-1);
1226   1              return err?err:(i-1);
1227   1      }
1228          
1229          
1230          
1231          
CX51 COMPILER V7.50   ITL                                                                  10/23/2014 09:48:34 PAGE 21  

1232          
1233          
1234          //
1235          
1236          //-------------------------------------
1237          //-------------------------------------
1238          //
1239          unsigned char MDBMission_Bill_Init( void )
1240          {
1241   1              u_char flag;
1242   1              u_int  BillDecimal = 0;
1243   1              u_char BillScale = 0,i = 0;
1244   1      
1245   1              DelayMs( 100 );
1246   1          MDBSerialInit();    
1247   1              DelayMs( 100 );
1248   1      
1249   1              flag=MDB_Bill_Reset();
1250   1              if(flag!=0)
1251   1          {
1252   2                      //sysMDBMission.billDeviceStatus|=0x01;
1253   2              }
1254   1              else
1255   1              {
1256   2              sysMDBMission.billDeviceStatus&=0xfe;
1257   2              }
1258   1      
1259   1              DelayMs( 500 );
1260   1              MDB_Bill_Poll( sysMDBMission.billBuf, &sysMDBMission.billBufLen );
1261   1              DelayMs( 100 );
1262   1              flag=MDB_Bill_Setup( sysMDBMission.billBuf, &sysMDBMission.billBufLen );
1263   1              if(flag!=0)
1264   1                      sysMDBMission.billDeviceStatus|=0x01;
1265   1              else
1266   1              {
1267   2                      //
1268   2                      BillDecimal = 100;
1269   2                  for(i = 0; i < sysMDBMission.billBuf[5]; i++) 
1270   2                  {
1271   3                         BillDecimal /= 10;
1272   3                  }
1273   2                      BillScale = ((((u_int)sysMDBMission.billBuf[3]) << 8) | sysMDBMission.billBuf[4]) * BillDecimal;
1274   2                      for(i=0;i<8;i++)
1275   2                      {
1276   3                              if(sysMDBMission.billBuf[11+i] == 0xFF) 
1277   3                              {
1278   4                                   break;
1279   4                              }
1280   3                              
1281   3                              SystemParameter.billValue[i] = (u_int)sysMDBMission.billBuf[i+11] * BillScale;  
1282   3                              if( (SystemParameter.billValue[i]>5000)&&(SystemParameter.billValue[i]!=10000) )
1283   3                                      SystemParameter.billValue[i]=0;
1284   3                      }       
1285   2                      
1286   2              sysMDBMission.billDeviceStatus&=0xfe;
1287   2              }
1288   1      
1289   1              DelayMs( 100 );
1290   1              flag=MDB_Bill_EXP_Identification( sysMDBMission.billBuf, &sysMDBMission.billBufLen );
1291   1              if(flag!=0)
1292   1                      sysMDBMission.billDeviceStatus|=0x01;
1293   1              else
CX51 COMPILER V7.50   ITL                                                                  10/23/2014 09:48:34 PAGE 22  

1294   1              sysMDBMission.billDeviceStatus&=0xfe;
1295   1      
1296   1              DelayMs( 100 );
1297   1              flag=MDB_Bill_Stacker( &sysMDBMission.billBuf[0], &sysMDBMission.billBuf[1] );
1298   1              DelayMs( 100 );
1299   1              if(flag!=0)
1300   1                      sysMDBMission.billDeviceStatus|=0x01;
1301   1              else
1302   1              sysMDBMission.billDeviceStatus&=0xfe;
1303   1      
1304   1              flag=MDBMission_Bill_Enable();
1305   1              if(flag!=0)
1306   1                      sysMDBMission.billDeviceStatus|=0x01;
1307   1              else
1308   1              sysMDBMission.billDeviceStatus&=0xfe;
1309   1      
1310   1              DelayMs( 100 );
1311   1              flag = MDB_Bill_Poll( sysMDBMission.billBuf, &sysMDBMission.billBufLen );
1312   1              if(flag==0)
1313   1                      sysMDBMission.billDeviceStatus&=0xfe;
1314   1              else
1315   1                  sysMDBMission.billDeviceStatus|=0x01;
1316   1              DelayMs( 100 );
1317   1              return ITL_ERR_NULL;
1318   1      }
1319          
1320          /*
1321          //
1322          unsigned char MDBMission_Bill_InitForTest( void )
1323          {
1324                  u_char flag;
1325                  uchar typesec=0;
1326          
1327                  DelayMs( 100 );
1328              MDBSerialInit();    
1329                  DelayMs( 100 );
1330          
1331                  flag=MDB_Bill_Reset();
1332                  if(flag!=0)
1333              {
1334                          //sysMDBMission.billDeviceStatus|=0x01;
1335                  }
1336                  else
1337                  {
1338                  sysMDBMission.billDeviceStatus&=0xfe;
1339                  }
1340          
1341                  DelayMs( 500 );
1342                  MDB_Bill_Poll( sysMDBMission.billBuf, &sysMDBMission.billBufLen );
1343                  DelayMs( 100 );
1344                  flag=MDB_Bill_Setup( sysMDBMission.billBuf, &sysMDBMission.billBufLen );
1345                  if(flag!=0)
1346                          sysMDBMission.billDeviceStatus|=0x01;
1347                  else
1348                  sysMDBMission.billDeviceStatus&=0xfe;
1349          
1350                  DelayMs( 100 );
1351                  flag=MDB_Bill_Stacker( &sysMDBMission.billBuf[0], &sysMDBMission.billBuf[1] );
1352                  DelayMs( 100 );
1353                  if(flag!=0)
1354                          sysMDBMission.billDeviceStatus|=0x01;
1355                  else
CX51 COMPILER V7.50   ITL                                                                  10/23/2014 09:48:34 PAGE 23  

1356                  sysMDBMission.billDeviceStatus&=0xfe;
1357          
1358                  //3
1359              if(SystemParameter.billValue[0]>0)
1360                          typesec |= 0x01;
1361                  if(SystemParameter.billValue[1]>0)
1362                          typesec |= 0x02;
1363                  if(SystemParameter.billValue[2]>0)
1364                          typesec |= 0x04;
1365                  if(SystemParameter.billValue[3]>0)
1366                          typesec |= 0x08;
1367                  if(SystemParameter.billValue[4]>0)
1368                          typesec |= 0x10;
1369                  if(SystemParameter.billValue[5]>0)
1370                          typesec |= 0x20;
1371                  if(SystemParameter.billValue[6]>0)
1372                          typesec |= 0x40;
1373                  if(SystemParameter.billValue[7]>0)
1374                          typesec |= 0x80;
1375                  
1376                  flag=MDB_Bill_Type(  0x00, typesec, 0xff, 0xff );
1377                  if(flag!=0)
1378                          sysMDBMission.billDeviceStatus|=0x01;
1379                  else
1380                  sysMDBMission.billDeviceStatus&=0xfe;
1381          
1382                  DelayMs( 100 );
1383                  flag = MDB_Bill_Poll( sysMDBMission.billBuf, &sysMDBMission.billBufLen );
1384                  if(flag==0)
1385                          sysMDBMission.billDeviceStatus&=0xfe;
1386                  else
1387                      sysMDBMission.billDeviceStatus|=0x01;
1388                  DelayMs( 100 );
1389                  return ITL_ERR_NULL;
1390          }
1391          */
1392          
1393          //
1394          unsigned char MDBMission_Bill_Enable( void )
1395          {
1396   1          uchar  mission;
1397   1              uchar typesec=0;
1398   1          //1.
1399   1          MDBSerialInit();  
1400   1          //;by gzz 20111019
1401   1          if(SystemParameter.BillNo==1)
1402   1              {
1403   2                  if(SystemParameter.billValue[0]>0)
1404   2                              typesec |= 0x01;
1405   2                      if(SystemParameter.billValue[1]>0)
1406   2                              typesec |= 0x02;
1407   2                      if(SystemParameter.billValue[2]>0)
1408   2                              typesec |= 0x04;
1409   2                      if(SystemParameter.billValue[3]>0)
1410   2                              typesec |= 0x08;
1411   2                      if(SystemParameter.billValue[4]>0)
1412   2                              typesec |= 0x10;
1413   2                      if(SystemParameter.billValue[5]>0)
1414   2                              typesec |= 0x20;
1415   2                      if(SystemParameter.billValue[6]>0)
1416   2                              typesec |= 0x40;
1417   2                      if(SystemParameter.billValue[7]>0)
CX51 COMPILER V7.50   ITL                                                                  10/23/2014 09:48:34 PAGE 24  

1418   2                              typesec |= 0x80;
1419   2          }
1420   1              
1421   1              mission=MDB_Bill_Type(  0x00, typesec, 0xff, 0xff );    
1422   1              //3.
1423   1          if( mission == 0x00 )
1424   1          { 
1425   2             sysMDBMission.billIsEnable = 1;
1426   2             sysMDBMission.billDeviceStatus &= 0xfe;
1427   2                 return 0;
1428   2          }
1429   1          else
1430   1          {      
1431   2             sysMDBMission.billDeviceStatus |= 0x01;
1432   2                 return 0x80;
1433   2          }           
1434   1      }
1435          
1436          
1437          
1438          //
1439          unsigned char MDBMission_Bill_Disable( void )
1440          {
1441   1         uchar mission;
1442   1         //1.
1443   1         MDBSerialInit();
1444   1         //2.
1445   1         mission=MDB_Bill_Type(  0x00, 0x00, 0xff, 0xff );
1446   1         //3.
1447   1         if( mission == 0x00 )
1448   1         {
1449   2             sysMDBMission.billIsEnable = 0;
1450   2             sysMDBMission.billDeviceStatus &= 0xfe;
1451   2         }
1452   1         else
1453   1         {
1454   2             sysMDBMission.billDeviceStatus |= 0x01;
1455   2         }
1456   1         return 0;
1457   1      }
1458          
1459          //
1460          //0x80: comms error
1461          //0x00: ok
1462          uchar MDB_Bill_Reset( void )   //Reset 
1463          {
1464   1              uchar Reset_r[1]={0};
1465   1              return Session(0x30,Reset_r,0);  //,
1466   1      }
1467          //-------------------------------------
1468          //------------------------------------
1469          
1470          uchar MDB_Bill_Setup( uchar *buf, uchar *len )   //Setup 
1471          {
1472   1              uchar Reset_r[1]={0};
1473   1              uchar candu;
1474   1              uchar i;
1475   1              candu=Session(0x31,Reset_r,0);
1476   1              if(candu>=0x80) return candu;
1477   1              else
1478   1              {
1479   2                      for(i=0;i<candu;i++)
CX51 COMPILER V7.50   ITL                                                                  10/23/2014 09:48:34 PAGE 25  

1480   2                      {
1481   3                          buf[i]=sysMDBMission.buff[i];
1482   3                              //*buf++ = sysMDBMission.buff[i];
1483   3                              if(i>10)
1484   3                                      sysMDBMission.Pc_billBuf[i]=(buf[i]>100)?0:buf[i];
1485   3                              else
1486   3                                      sysMDBMission.Pc_billBuf[i]=buf[i];     
1487   3                      }
1488   2                      *len=candu;
1489   2                      return 0x00;
1490   2              }
1491   1      }
1492          //-------------------------------------
1493          //------------------------------------
1494          
1495          //0x80 = com error
1496          //0x00 = ok
1497          uchar MDB_Bill_Poll(uchar *buf, uchar *len)   //
1498          {
1499   1              uchar Poll_r[1]={0};
1500   1              uchar   candu;
1501   1              uchar   i;
1502   1              candu=Session(0x33,Poll_r,0);  //,poll
1503   1              if(candu>=0x80) return  0x80;
1504   1              else
1505   1              {
1506   2                      for(i=0;i<candu;i++)
1507   2                              buf[i]=sysMDBMission.buff[i];
1508   2                      *len=candu;
1509   2                      return 0x00;
1510   2              }
1511   1              
1512   1      }
1513          
1514          
1515          uchar MDB_Bill_Poll_API( void ) 
1516          {
1517   1          uchar mission = 0;
1518   1          //1.
1519   1          MDBSerialInit();
1520   1          //2.
1521   1          mission = MDB_Bill_Poll( sysMDBMission.billBuf, &sysMDBMission.billBufLen );
1522   1              //3.
1523   1          if( mission == 0x00 )
1524   1          {
1525   2             sysMDBMission.billDeviceStatus &= 0xfe;
1526   2          }
1527   1          else
1528   1          {
1529   2             sysMDBMission.billDeviceStatus |= 0x01;
1530   2          }
1531   1          return 0;    
1532   1      }
1533          
1534          //------------------------------------
1535          //0x80 = com error
1536          //0x00 = not, 0x01=stacked,0x02=
1537          uchar MDB_Bill_IfStacked( uchar *buf, uchar *len ) //
1538          {
1539   1              uchar IfStacked_r[1]={0};
1540   1              uchar   candu;
1541   1              uchar   i;
CX51 COMPILER V7.50   ITL                                                                  10/23/2014 09:48:34 PAGE 26  

1542   1              
1543   1          MDBSerialInit();
1544   1              candu=Session(0x33,IfStacked_r,0);  //,poll
1545   1              if( candu >= 0x80 ) 
1546   1              {
1547   2                  return candu;
1548   2              }
1549   1              else
1550   1              {
1551   2                      *len=candu;
1552   2                      if(candu==0) return 0x00;
1553   2                      for(i=0;i<candu;i++)
1554   2                      {
1555   3                              buf[i]=sysMDBMission.buff[i];
1556   3                      }
1557   2                      //*billType=sysMDBMission.buff[0]&0x0f;
1558   2                  if( sysMDBMission.buff[0] <= 0x7f )
1559   2                      {
1560   3                              return  0x02;   //other message(maybe error status)
1561   3                      }
1562   2                      else if((sysMDBMission.buff[0]&0xf0)==0x80) 
1563   2                      {
1564   3                              return  0x01;
1565   3                      }
1566   2                      return  0x00;
1567   2              }
1568   1      }
1569          //-------------------------------------
1570          //------------------------------------
1571          
1572          //0x80 = com error
1573          //0x00 = not, 0x01=secrow,0x02=
1574          uchar MDB_Bill_IfSecrow( uchar *buf, uchar *len, uchar *billType )  //
1575          {
1576   1              uchar IfSecrow_r[1]={0};
1577   1              uchar   candu;
1578   1              uchar   i;
1579   1              static uchar errFlag=0;
1580   1                      
1581   1          MDBSerialInit();
1582   1              candu=Session(0x33,IfSecrow_r,0);  //,poll
1583   1              if( candu >= 0x80 ) 
1584   1              {               
1585   2                      if(errFlag>=5)
1586   2                      {
1587   3                      sysMDBMission.billDeviceStatus |= 0x01;
1588   3                      }
1589   2                      else
1590   2                      {
1591   3                              errFlag++;
1592   3                      }
1593   2                  return candu;
1594   2              }
1595   1              else
1596   1              {
1597   2                      sysMDBMission.billDeviceStatus &= 0xfe;
1598   2                      errFlag=0;              
1599   2                      *len=candu;
1600   2                      if(candu==0)
1601   2                      {
1602   3                              sysMDBMission.billCashBuf = 0;//;by gzz 20121224 
1603   3                              sysMDBMission.billOthErr = 0;
CX51 COMPILER V7.50   ITL                                                                  10/23/2014 09:48:34 PAGE 27  

1604   3                              return 0x00;
1605   3                      }
1606   2                      for(i=0;i<candu;i++)
1607   2                      {
1608   3                              buf[i]=sysMDBMission.buff[i];
1609   3                      }
1610   2                      for(i = 0; i < candu; i++) 
1611   2                      {                       
1612   3                          if( sysMDBMission.buff[i] <= 0x7f )
1613   3                              {
1614   4                                      /*
1615   4                                      //;by gzz 20121224
1616   4                                      if( ( sysMDBMission.buff[0] == 0x08 )||( sysMDBMission.buff[0] == 0x09 ) )
1617   4                                      //if( sysMDBMission.buff[0] == 0x08 )
1618   4                                      {
1619   4                                              sysMDBMission.billCashBuf = 1;
1620   4                                      }
1621   4                                      */
1622   4                                      switch(sysMDBMission.buff[i]) 
1623   4                                      {
1624   5                                  case 0x01:                                   //defective motor    
1625   5                                      //TraceBill("\r\n Drvbill motor");
1626   5                                              sysMDBMission.billOthErr |= 0x01;
1627   5                                              break;
1628   5                              
1629   5                                      case 0x02:                                       //sensor problem
1630   5                                              //TraceBill("\r\n Drvbill sensor");
1631   5                                                  sysMDBMission.billOthErr |= 0x02;
1632   5                                              break;
1633   5                              
1634   5                                      case 0x03:                                       //validator busy
1635   5                                              //TraceBill("\r\n Drvbil busy");
1636   5                                              break;
1637   5                              
1638   5                                      case 0x04:                                       //rom chksum err
1639   5                                              //TraceBill("\r\n Drvbill chksum");
1640   5                                              sysMDBMission.billOthErr |= 0x04;
1641   5                                      break;
1642   5                              
1643   5                                      case 0x05:                                       //validator jammed
1644   5                                              //TraceBill("\r\n Drvbill jammed");
1645   5                                                  sysMDBMission.billOthErr |= 0x08;                          
1646   5                                              break;
1647   5                              
1648   5                                      case 0x06:                                       //validator was reset
1649   5                                              //TraceBill("\r\n Drvbil reset");
1650   5                                                      break;
1651   5                                       
1652   5                                      case 0x07:                                       //bill removed 
1653   5                                              //TraceBill("\r\n Drvbil removed");
1654   5                                              break;
1655   5                               
1656   5                                      case 0x08:                                       //cash box out of position
1657   5                                              //TraceBill("\r\n Drvbill removeCash");
1658   5                                                  sysMDBMission.billCashBuf = 1;
1659   5                                              break;
1660   5                              
1661   5                                      case 0x09:                                       //validator disabled   
1662   5                                              //TraceBill("\r\n Drvbill disabled");
1663   5                                              sysMDBMission.billOthErr |= 0x10;
1664   5                                                      break;
1665   5                              
CX51 COMPILER V7.50   ITL                                                                  10/23/2014 09:48:34 PAGE 28  

1666   5                                      case 0x0A:                                       //invalid escrow request
1667   5                                              //TraceBill("\r\n Drvbil invalid");
1668   5                                              break;
1669   5                              
1670   5                                      case 0x0B:                                       //bill rejected
1671   5                                              //TraceBill("\r\n Drvbil rejected");
1672   5                                              break;
1673   5                              
1674   5                                      case 0x0C:                                       //possible credited bill removal
1675   5                                              //TraceBill("\r\n Drvbill cashErr");
1676   5                                                  sysMDBMission.billOthErr |= 0x20;   
1677   5                                              break;
1678   5                              
1679   5                                      default:
1680   5                                                      //TraceBill("\r\n Drvbill default");    
1681   5                                                      sysMDBMission.billOthErr = 0;
1682   5                                                      sysMDBMission.billCashBuf = 0;
1683   5                                                  break;
1684   5                               }
1685   4                                      //return  0x02;   //other message(maybe error status)
1686   4                              }
1687   3                              else if((sysMDBMission.buff[i]&0xf0)==0x90) 
1688   3                              {
1689   4                                      *billType=sysMDBMission.buff[i]&0x0f;
1690   4                                      return  0x01;
1691   4                              }
1692   3                      }
1693   2                      return  0x00;
1694   2              }       
1695   1      }
1696          
1697          //-------------------------------------
1698          //------------------------------------
1699          //0x80 = com error
1700          //0x00 = not, 0x01=returned,0x02=
1701          uchar MDB_Bill_IfReturned( uchar *buf, uchar *len, uchar *billType )  //
1702          {
1703   1              uchar IfReturned_r[1]={0};
1704   1              uchar   candu;
1705   1              uchar   i;
1706   1                      
1707   1          MDBSerialInit();
1708   1              candu=Session(0x33,IfReturned_r,0);  //,poll
1709   1              if( candu >= 0x80 ) 
1710   1              {
1711   2                  return candu;
1712   2              }
1713   1              else
1714   1              {
1715   2                      *len=candu;
1716   2                      if(candu==0) return 0x00;
1717   2                      for(i=0;i<candu;i++)
1718   2                      {
1719   3                              buf[i]=sysMDBMission.buff[i];
1720   3                      }
1721   2                      *billType=sysMDBMission.buff[0]&0x0f;
1722   2                  if( sysMDBMission.buff[0] <= 0x7f )
1723   2                      {
1724   3                              return  0x02;   //other message(maybe error status)
1725   3                      }
1726   2                      else if((sysMDBMission.buff[0]&0xf0)==0xa0) 
1727   2                      {
CX51 COMPILER V7.50   ITL                                                                  10/23/2014 09:48:34 PAGE 29  

1728   3                              return  0x01;
1729   3                      }
1730   2                      return  0x00;
1731   2              }       
1732   1      }
1733          
1734          //-------------------------------------
1735          //------------------------------------
1736          //0x80 = com error
1737          //0x00 = not, 0x01=DBReject,0x02=
1738          uchar MDB_Bill_IfDBReject( uchar *buf, uchar *len, uchar *billType )  //
1739          {
1740   1              uchar IfDBReject_r[1]={0};
1741   1              uchar   candu;
1742   1              uchar   i;
1743   1                      
1744   1          MDBSerialInit();
1745   1              candu=Session(0x33,IfDBReject_r,0);  //,poll
1746   1              if( candu >= 0x80 ) 
1747   1              {
1748   2                  return candu;
1749   2              }
1750   1              else
1751   1              {
1752   2                      *len=candu;
1753   2                      if(candu==0) return 0x00;
1754   2                      for(i=0;i<candu;i++)
1755   2                      {
1756   3                              buf[i]=sysMDBMission.buff[i];
1757   3                      }
1758   2                      *billType=sysMDBMission.buff[0]&0x0f;
1759   2                  if( sysMDBMission.buff[0] <= 0x7f )
1760   2                      {
1761   3                              return  0x02;   //other message(maybe error status)
1762   3                      }
1763   2                      else if((sysMDBMission.buff[0]&0xf0)==0xc0) 
1764   2                      {
1765   3                              return  0x01;
1766   3                      }
1767   2                      return  0x00;
1768   2              }       
1769   1      }
1770          //-------------------------------------
1771          //------------------------------------
1772          //
1773          //0x80: comms error
1774          //0x00: ok
1775          uchar MDB_Bill_EscrowCtr( uchar control )  
1776          {
1777   1          uchar EscrowCtr_r[1];
1778   1              uchar   candu;
1779   1                      
1780   1          MDBSerialInit();
1781   1          EscrowCtr_r[0]=control;
1782   1              candu=Session(0x35,EscrowCtr_r,1);  //
1783   1              if(candu>=0x80) return  0x80;
1784   1              else  return    0x00;
1785   1      
1786   1      }
1787          
1788          //-------------------------------------
1789          //------------------------------------
CX51 COMPILER V7.50   ITL                                                                  10/23/2014 09:48:34 PAGE 30  

1790          
1791          
1792          //
1793          //0x80: comms error
1794          //0x00: ok
1795          uchar MDB_Bill_Type( uchar enable1, uchar enable2, uchar escrow1, uchar escrow2 )  
1796          {
1797   1           uchar TYPE_r[4];
1798   1               TYPE_r[0]=enable1;
1799   1               TYPE_r[1]=enable2;
1800   1           TYPE_r[2]=escrow1;
1801   1               TYPE_r[3]=escrow2;
1802   1          return Session(0x34,TYPE_r,4); 
1803   1      }
1804          //-------------------------------------
1805          //-------------------------------------
1806          // 
1807          //0x80: comms error
1808          //0x00: ok
1809          //(Fxxxxxxx)  (xxxxxxxx) 
1810          //F = 1 if stacker is full, 0 if not.
1811          //xxxxxxxxxxxxxxx  =  The number of bills in the stacker.
1812          uchar MDB_Bill_Stacker( uchar * dat1, uchar *dat2 )  
1813          {
1814   1           
1815   1          uchar Stacker_r[1]={0};
1816   1              uchar   candu;
1817   1                      
1818   1          MDBSerialInit();
1819   1              candu=Session(0x36,Stacker_r,0);  //
1820   1              *dat1=sysMDBMission.buff[0]&0x7f;
1821   1              *dat2=sysMDBMission.buff[1];
1822   1      
1823   1      
1824   1          //;by gzz 20111017
1825   1          if(sysMDBMission.buff[0]&0x80)
1826   1              sysMDBMission.billIsFull = 1;
1827   1          else
1828   1              sysMDBMission.billIsFull = 0;
1829   1      
1830   1              if(candu>=0x80) return  0x80;
1831   1              else  return    0x00;
1832   1      }
1833          
1834          
1835          //------------------------------------------------------------------------------
1836          //0x80: comms error
1837          //0x00: ok
1838          //z1-z33
1839          uchar MDB_Bill_EXP_Identification(uchar *buf, uchar *len)
1840          {
1841   1              uchar VMCdata[1]={0x00};
1842   1              uchar length;
1843   1              uchar i;
1844   1              
1845   1          //MDBSerialInit();
1846   1              length=Session(0x37,VMCdata,1);
1847   1              if(length>=0x80) return length;
1848   1          else
1849   1          {
1850   2                for(i=0;i<length;i++)
1851   2                {
CX51 COMPILER V7.50   ITL                                                                  10/23/2014 09:48:34 PAGE 31  

1852   3                  buf[i]=sysMDBMission.buff[i];
1853   3                      sysMDBMission.billIDENTITYBuf[i] = buf[i];
1854   3                }
1855   2                *len=length;
1856   2                return 0x00;
1857   2          }    
1858   1      }
1859          
1860          
1861          
1862          //
1863          //------------------------------------------------------------------------------
1864          //
1865          unsigned char MDBMission_Coin_Init( void )
1866          {
1867   1              
1868   1          uchar flag = 0;
1869   1              u_int  CoinDecimal = 0;
1870   1              u_char CoinScale = 0,i = 0;
1871   1              
1872   1              DelayMs( 100 );
1873   1          MDBSerialInit();
1874   1              DelayMs( 100 );
1875   1      
1876   1              flag=MDB_Coin_Reset();
1877   1              if( flag != 0 )
1878   1              {
1879   2                      //sysMDBMission.coinDeviceStatus |=0x01;
1880   2              }
1881   1              else
1882   1              {
1883   2              sysMDBMission.coinDeviceStatus &=0xfe;
1884   2              }
1885   1      
1886   1              DelayMs( 1000 );
1887   1              flag = MDB_Coin_Poll( sysMDBMission.coinBuf, &sysMDBMission.coinBufLen);
1888   1          if( flag != 0 )
1889   1                      sysMDBMission.coinDeviceStatus |=0x01;
1890   1              else
1891   1              sysMDBMission.coinDeviceStatus &=0xfe;
1892   1              DelayMs( 100 );
1893   1              flag=MDB_Coin_Setup( sysMDBMission.coinBuf, &sysMDBMission.coinBufLen);
1894   1              if(flag!=0)
1895   1              {
1896   2                      sysVPMission.scalFactor = 50;
1897   2                      sysVPMission.decimalPlaces = 1;
1898   2                      sysMDBMission.coinDeviceStatus|=0x01;
1899   2              }
1900   1              else
1901   1              {
1902   2                      sysVPMission.scalFactor = sysMDBMission.coinBuf[3];
1903   2                      sysVPMission.decimalPlaces = sysMDBMission.coinBuf[4];
1904   2                      //
1905   2                      
1906   2                      CoinDecimal = 100;
1907   2                  for(i = 0; i < sysMDBMission.coinBuf[4]; i++) 
1908   2                  {
1909   3                         CoinDecimal /= 10;
1910   3                  }
1911   2                      CoinScale = sysMDBMission.coinBuf[3] * CoinDecimal;
1912   2                      for(i=0;i<6;i++)
1913   2                      {
CX51 COMPILER V7.50   ITL                                                                  10/23/2014 09:48:34 PAGE 32  

1914   3                              if(sysMDBMission.coinBuf[7+i] == 0xFF)
1915   3                              {
1916   4                                   break;
1917   4                              }                       
1918   3                              SystemParameter.coinValue[i] = (u_int)sysMDBMission.coinBuf[7+i] * CoinScale;
1919   3                              if( (SystemParameter.coinValue[i]>5000)&&(SystemParameter.coinValue[i]!=10000) )
1920   3                                      SystemParameter.coinValue[i]=0;
1921   3                      }       
1922   2                      /**/
1923   2              sysMDBMission.coinDeviceStatus&=0xfe;
1924   2              }
1925   1              DelayMs( 100 );
1926   1              flag = MDB_Coin_EXP_Identification( sysMDBMission.coinBuf, &sysMDBMission.coinBufLen);
1927   1          if( flag != 0 )
1928   1                      sysMDBMission.coinDeviceStatus |=0x01;
1929   1              else
1930   1              sysMDBMission.coinDeviceStatus &=0xfe;
1931   1              DelayMs( 100 );
1932   1          //
1933   1              flag=MDB_Coin_TubeSta_API();
1934   1              if(flag!=0)
1935   1          {
1936   2                      sysMDBMission.coinDeviceStatus|=0x01;
1937   2          }
1938   1              else
1939   1          {
1940   2              sysMDBMission.coinDeviceStatus&=0xfe;
1941   2          }
1942   1              DelayMs( 100 );
1943   1          //
1944   1              flag=MDBMission_Coin_Enable();
1945   1              if(flag!=0)
1946   1                      sysMDBMission.coinDeviceStatus |= 0x01;
1947   1              else
1948   1              sysMDBMission.coinDeviceStatus &= 0xfe;
1949   1              DelayMs( 100 );
1950   1              flag=MDB_Coin_Poll( sysMDBMission.coinBuf, &sysMDBMission.coinBufLen );
1951   1              if( flag == 0 )
1952   1              {
1953   2                      sysMDBMission.coinDeviceStatus &=0xfe;
1954   2              }
1955   1              else
1956   1              {
1957   2                      sysMDBMission.coinDeviceStatus |=0x01;
1958   2              }
1959   1              DelayMs( 100 );     
1960   1          flag = MDB_Coin_EXP_FeatureEnable( 0xff, 0xff, 0xff, 0xff );
1961   1              if( flag == 0 )
1962   1              {
1963   2                      sysMDBMission.coinDeviceStatus &=0xfe;
1964   2              }
1965   1              else
1966   1              {
1967   2                      sysMDBMission.coinDeviceStatus |=0x01;
1968   2              }
1969   1              DelayMs( 100 );
1970   1              return ITL_ERR_NULL;
1971   1      }
1972          
1973          
1974          
1975          //
CX51 COMPILER V7.50   ITL                                                                  10/23/2014 09:48:34 PAGE 33  

1976          uchar MDBMission_Coin_Enable(void)
1977          {
1978   1         uchar mission;
1979   1         uchar typesec = 0;
1980   1         //1.
1981   1         MDBSerialInit();
1982   1         //2.
1983   1         //;by gzz 20111019
1984   1         if(SystemParameter.coinOn==1)
1985   1         {
1986   2                 if(SystemParameter.coinValue[0]>0)
1987   2                      typesec |= 0x01;
1988   2                 if(SystemParameter.coinValue[1]>0)
1989   2                      typesec |= 0x02;
1990   2                 if(SystemParameter.coinValue[2]>0)
1991   2                      typesec |= 0x04;
1992   2                 if(SystemParameter.coinValue[3]>0)
1993   2                      typesec |= 0x08;
1994   2                 if(SystemParameter.coinValue[4]>0)
1995   2                      typesec |= 0x10;
1996   2                 if(SystemParameter.coinValue[5]>0)
1997   2                      typesec |= 0x20;
1998   2         }
1999   1      
2000   1         mission=MDB_Coin_Type(  0x00, typesec, 0xff, 0xff );
2001   1         if(mission!=0)
2002   1         {
2003   2                      sysMDBMission.coinDeviceStatus |= 0x01;
2004   2                      return 0x80;
2005   2         }
2006   1         else
2007   1         {
2008   2              sysMDBMission.coinIsEnable = 1;
2009   2              sysMDBMission.coinDeviceStatus &= 0xfe;
2010   2                      return 0x00;
2011   2         }  
2012   1      }
2013          
2014          
2015          //------------------------------------------------------------------------------
2016          //
2017          uchar MDBMission_Coin_Disable(void)
2018          {
2019   1         uchar mission;
2020   1         //1.
2021   1         MDBSerialInit();
2022   1         //2.
2023   1         mission=MDB_Coin_Type(  0x00, 0x00, 0xff, 0xff );
2024   1        //3.
2025   1         if( mission == 0x00 )
2026   1         {
2027   2              sysMDBMission.coinIsEnable = 0;
2028   2              sysMDBMission.coinDeviceStatus &= 0xfe;
2029   2                      return 0x00;
2030   2         }
2031   1         else
2032   1         {
2033   2                      sysMDBMission.coinDeviceStatus |= 0x01;//by gzz 20120323
2034   2                      return 0x80;
2035   2         }
2036   1      }
2037          
CX51 COMPILER V7.50   ITL                                                                  10/23/2014 09:48:34 PAGE 34  

2038          
2039          //------------------------------------------------------------------------------
2040          //Reset 
2041          //0x80 = com error
2042          //0x00 = ok
2043          uchar MDB_Coin_Reset(void)
2044          {
2045   1          uchar VMCdata[1]={0};
2046   1          return Session(0x08,VMCdata,0);  //,
2047   1      }
2048          
2049          //------------------------------------------------------------------------------
2050          //Setup 
2051          //0x80 = com error
2052          //0x00 = ok
2053          uchar MDB_Coin_Setup(uchar *buf,uchar *len)
2054          {
2055   1              uchar VMCdata[1]={0};
2056   1              uchar length;
2057   1              uchar i;
2058   1      
2059   1              length=Session(0x09,VMCdata,0);
2060   1              if(length>=0x80) return length;
2061   1          else
2062   1          {
2063   2                for(i=0;i<length;i++)
2064   2                {
2065   3                  buf[i]=sysMDBMission.buff[i];
2066   3                      if(i>6)
2067   3                              sysMDBMission.Pc_coinBuf[i]=(buf[i]>100)?0:buf[i];
2068   3                      else
2069   3                              sysMDBMission.Pc_coinBuf[i]=buf[i];     
2070   3                }
2071   2                *len=length;
2072   2                return 0x00;
2073   2          }
2074   1      }
2075          
2076          //------------------------------------------------------------------------------
2077          //
2078          //After reset more 500 ms, 
2079          //0x80: comms error
2080          //0x00: ok
2081          uchar MDB_Coin_TubeSta(uchar *buf,uchar *len)  
2082          {
2083   1              uchar VMCdata[1]={0};
2084   1              uchar length;
2085   1              uchar i;
2086   1              
2087   1              //MDBSerialInit();
2088   1              length=Session(0x0a,VMCdata,0);
2089   1              if(length>=0x80)
2090   1          {
2091   2                      return length;
2092   2          }
2093   1              else
2094   1              {  
2095   2                for(i=0;i<length;i++)
2096   2            {
2097   3                  buf[i]=sysMDBMission.buff[i];
2098   3                  *len=length;
2099   3            }
CX51 COMPILER V7.50   ITL                                                                  10/23/2014 09:48:34 PAGE 35  

2100   2                return 0x00;
2101   2          }    
2102   1      }
2103          
2104          
2105          uchar MDB_Coin_TubeSta_API( void )  
2106          {
2107   1              uchar mission;
2108   1      
2109   1              MDBSerialInit();
2110   1          mission = MDB_Coin_TubeSta( sysMDBMission.coinBuf, &sysMDBMission.coinBufLen);
2111   1          if( mission == 0x00 )
2112   1          {
2113   2                  if( sysMDBMission.coinBufLen >= 4 )
2114   2                      {
2115   3                      sysMDBMission.coin5jNum = sysMDBMission.coinBuf[2];
2116   3                      sysMDBMission.coin1yNum = sysMDBMission.coinBuf[3];
2117   3                      sysMDBMission.coin5jValue = sysMDBMission.coin5jNum*SystemParameter.coinValue[0];
2118   3                      sysMDBMission.coin1yValue = sysMDBMission.coin1yNum*SystemParameter.coinValue[1];
2119   3                  sysMDBMission.coinAllValue = sysMDBMission.coin5jValue + sysMDBMission.coin1yValue;
2120   3                              
2121   3              }
2122   2                      sysMDBMission.coinDeviceStatus &= 0xfe;
2123   2                      return 0;
2124   2          }
2125   1              else
2126   1              {
2127   2                  sysMDBMission.coinDeviceStatus |= 0x01;
2128   2                  return mission;     
2129   2              }
2130   1      
2131   1      }
2132          
2133          //------------------------------------------------------------------------------
2134          //
2135          //0x80 = com error
2136          //0x00 = ok
2137          uchar MDB_Coin_Poll(uchar *buf,uchar *len)
2138          {
2139   1              uchar VMCdata[1]={0};
2140   1              uchar length;
2141   1              uchar i;
2142   1      
2143   1          length=Session(0x0b,VMCdata,0);
2144   1          if(length>=0x80) return length;
2145   1          else
2146   1          {
2147   2                for(i=0;i<length;i++)
2148   2                  buf[i]=sysMDBMission.buff[i];
2149   2                *len=length;
2150   2                return 0x00;
2151   2          }    
2152   1      }
2153          
2154          uchar MDB_Coin_Poll_API( void )
2155          {
2156   1          uchar mission = 0;
2157   1              //1.
2158   1          MDBSerialInit();
2159   1          //2.
2160   1              mission =   MDB_Coin_Poll( sysMDBMission.coinBuf, &sysMDBMission.coinBufLen );
2161   1              if( mission == 0x00 )
CX51 COMPILER V7.50   ITL                                                                  10/23/2014 09:48:34 PAGE 36  

2162   1              {
2163   2                  sysMDBMission.coinDeviceStatus &= 0xfe; 
2164   2              }
2165   1              else
2166   1              {
2167   2                      sysMDBMission.coinDeviceStatus |= 0x01;
2168   2              }
2169   1          return 0;
2170   1      }
2171          
2172          //------------------------------------------------------------------------------
2173          //
2174          //0x80 = com error
2175          //0x00 = not, 0x01=dispensed, 0x02=
2176          uchar MDB_Coin_IfDispensed(uchar *buf,uchar *len,uchar *coinType,uchar *coinDispensedNum,uchar *coinStock)
2177          {
2178   1              uchar VMCdata[1]={0};
2179   1              uchar length;
2180   1              uchar i;
2181   1      
2182   1              MDBSerialInit();
2183   1              length=Session(0x0b,VMCdata,0);
2184   1              if(length>=0x80) return length;
2185   1          else
2186   1          {
2187   2                        *len=length;
2188   2                        if(length==0) return 0x00;
2189   2                        for(i=0;i<length;i++)
2190   2                          buf[i]=sysMDBMission.buff[i];
2191   2                        if(sysMDBMission.buff[0]<0x40) return 0x02;
2192   2                        if(sysMDBMission.buff[0]&0x80)
2193   2                    {
2194   3                          *coinDispensedNum=(sysMDBMission.buff[0]&0x70)/0x10;
2195   3                          *coinType=sysMDBMission.buff[0]&0x0f;
2196   3                          *coinStock=sysMDBMission.buff[1];
2197   3                          return 0x01;
2198   3                    }
2199   2                    return 0x00;
2200   2               }    
2201   1      }
2202          
2203          //------------------------------------------------------------------------------
2204          //
2205          //0x80 = com error
2206          //0x00 = not, 0x01=escrow, 0x02=
2207          uchar MDB_Coin_IfDeposited(uchar *buf,uchar *len,uchar *coinType,uchar *coinStock )  
2208          {
2209   1        
2210   1        uchar VMCdata[1]={0};
2211   1        uchar length;
2212   1        uchar i;
2213   1        static uchar errFlag=0;
2214   1        //u_char xdata str[20];
2215   1        //u_char xdata lens = 0;
2216   1      
2217   1        MDBSerialInit();
2218   1        DelayMs( 100 );
2219   1        length=Session(0x0b,VMCdata,0);
2220   1        if(length>=0x80) 
2221   1        {
2222   2              if(errFlag>=5)
2223   2              {
CX51 COMPILER V7.50   ITL                                                                  10/23/2014 09:48:34 PAGE 37  

2224   3              sysMDBMission.coinDeviceStatus |= 0x01;
2225   3              }
2226   2              else
2227   2              {
2228   3                      errFlag++;
2229   3              }    
2230   2              //DisplayStr( 0, 0, 1, "coinerr", 7 );
2231   2              //WaitForWork( 2000, NULL );
2232   2              return length;
2233   2        }
2234   1        else
2235   1        {
2236   2                sysMDBMission.coinDeviceStatus &= 0xfe;
2237   2                errFlag=0;    
2238   2                *len=length;
2239   2                if(length==0) 
2240   2                {
2241   3                      sysMDBMission.coinOthErr = 0;
2242   3                      return 0x00;
2243   3                }
2244   2            for(i=0;i<length;i++)
2245   2            {
2246   3              buf[i]=sysMDBMission.buff[i];
2247   3            }
2248   2                //lens = sprintf( str, "coin=%x,%x" , buf[0],buf[1]); 
2249   2                //DisplayStr( 0, 0, 1, str, lens );
2250   2                //WaitForWork( 2000, NULL );                  
2251   2                for(i = 0; i < length; i++) 
2252   2                { 
2253   3                        //report changer activity
2254   3                        //coins dispensed manually
2255   3                        if(sysMDBMission.buff[i] & 0x80) 
2256   3                        {                   
2257   4                                      i++; //2
2258   4                        } 
2259   3                        else if((sysMDBMission.buff[i] & 0xC0) == 0x40) 
2260   3                        {      
2261   4                                      //coins deposited
2262   4                                      if(((sysMDBMission.buff[i] & 0x30) == 0x10) || ((sysMDBMission.buff[i] & 0x30) == 0)) //in tubes
2263   4                                      {
2264   5                                          *coinType=sysMDBMission.buff[i]&0x0f;
2265   5                                          *coinStock=sysMDBMission.buff[i+1];
2266   5                                              //DisplayStr( 0, 0, 1, "getcoin", 7 );
2267   5                                          //WaitForWork( 2000, NULL );
2268   5                                      return 0x01;
2269   5                                  }
2270   4                                      i++; //2
2271   4                        } 
2272   3                        else if((sysMDBMission.buff[i] & 0xE0) == 0x20) 
2273   3                        {      //slug
2274   4                        }
2275   3                    else
2276   3                    {
2277   4                      /*
2278   4                        //------------------------
2279   4                        if( sysMDBMission.buff[i] == 0x01 )
2280   4                        {
2281   4                                //DisplayStr( 0, 0, 1, "1", 1 );
2282   4                                        //WaitForWork( 2000, NULL );
2283   4                            sysMDBMission.returnKeyFlag = 1;
2284   4                        }
2285   4                                */
CX51 COMPILER V7.50   ITL                                                                  10/23/2014 09:48:34 PAGE 38  

2286   4                                  switch(sysMDBMission.buff[i]) 
2287   4                                      {                                               
2288   5                                         case 0x01:                                    //escrow request       
2289   5                                                 sysMDBMission.returnKeyFlag = 1;
2290   5                                                 break;
2291   5      
2292   5                                         case 0x02:                                    //changer pay out busy
2293   5                                                 break;
2294   5      
2295   5                                         case 0x03:                                    //no credit
2296   5                                                 //
2297   5                                                 break;
2298   5      
2299   5                                         case 0x04:                                    //defective tube sensor                                                
2300   5                                                 //
2301   5                                                 sysMDBMission.coinOthErr |= 0x01;
2302   5                                                 break;
2303   5      
2304   5                                         case 0x05:                                    //double arriver
2305   5                                                 break;
2306   5      
2307   5                                         case 0x06:                                    //acceptor unplugged                                              
2308   5                                                 break;
2309   5      
2310   5                                         case 0x07:                                    //tube jam
2311   5                                                 //
2312   5                                                 sysMDBMission.coinOthErr |= 0x02;
2313   5                                                 break;
2314   5      
2315   5                                         case 0x08:                                    //rom chksum err
2316   5                                                 //ROM
2317   5                                                 sysMDBMission.coinOthErr |= 0x04;
2318   5                                                 break;
2319   5      
2320   5                                         case 0x09:                                    //coin routing err
2321   5                                                 //
2322   5                                                 sysMDBMission.coinOthErr |= 0x08;
2323   5                                                 break;
2324   5      
2325   5                                         case 0x0A:                                    //changer busy
2326   5                                                 break;
2327   5      
2328   5                                         case 0x0B:                                    //changer was reset
2329   5                                                 //
2330   5                                                 break;
2331   5      
2332   5                                         case 0x0C:                                    //coin jam
2333   5                                                 //
2334   5                                                 sysMDBMission.coinOthErr |= 0x10;
2335   5                                                 break;
2336   5      
2337   5                                         case 0x0D:                                //possible credited coin removal
2338   5                                                 //
2339   5                                                 sysMDBMission.coinOthErr |= 0x20;
2340   5                                                 break;
2341   5      
2342   5                                         default:     
2343   5                                                 sysMDBMission.coinOthErr = 0;        
2344   5                                                 break;
2345   5                                      }
2346   4                              //return 0x02;
2347   4                    }       
CX51 COMPILER V7.50   ITL                                                                  10/23/2014 09:48:34 PAGE 39  

2348   3                }
2349   2            return 0x00;
2350   2        }    
2351   1      }
2352          
2353          
2354          //------------------------------------------------------------------------------
2355          //
2356          //0x80: comms error
2357          //0x00: ok
2358          uchar MDB_Coin_Type(uchar typeCtr1,uchar typeCtr2,uchar dispenseCtr1,uchar dispenseCtr2)  
2359          {
2360   1              uchar VMCdata[4];
2361   1              VMCdata[0]=typeCtr1;
2362   1              VMCdata[1]=typeCtr2;
2363   1              VMCdata[2]=dispenseCtr1;
2364   1              VMCdata[3]=dispenseCtr2;
2365   1              return Session(0x0c,VMCdata,4);     
2366   1      }
2367          
2368          //,,
2369          uchar MDB_Coin_HopperEnable(void)
2370          {
2371   1         uchar mission;
2372   1         DelayMs( 100 );
2373   1         //1.
2374   1         MDBSerialInit();
2375   1         DelayMs( 100 );
2376   1         //2.
2377   1         mission=MDB_Coin_Type(  0x00, 0x00, 0xff, 0xff );
2378   1         DelayMs( 100 );
2379   1         mission=MDB_Bill_Type(  0x00, 0x00, 0x00, 0x00 );
2380   1         DelayMs( 100 );
2381   1         //3.
2382   1         ITLSerialInit();
2383   1         if(mission&0x80)
2384   1                      return ITL_ERR_COM;
2385   1         else
2386   1                      return ITL_ERR_NULL;
2387   1      }
2388          
2389          
2390          //------------------------------------------------------------------------------
2391          //
2392          //0x80: comms error
2393          //0x00: ok
2394          uchar MDB_Coin_Dispense( uchar type, uchar num ) 
2395          {
2396   1          
2397   1              uchar VMCdata[1];       
2398   1          MDBSerialInit();
2399   1              VMCdata[0] =  type&0x0f;
2400   1          VMCdata[0] |= ((num<<4)&0xf0);
2401   1              return Session(0x0d,VMCdata,1);
2402   1      }
2403          
2404          //------------------------------------------------------------------------------
2405          //0x80: comms error
2406          //0x00: ok
2407          //z1-z33
2408          uchar MDB_Coin_EXP_Identification(uchar *buf, uchar *len)
2409          {
CX51 COMPILER V7.50   ITL                                                                  10/23/2014 09:48:34 PAGE 40  

2410   1              uchar VMCdata[1]={0x00};
2411   1              uchar length;
2412   1              uchar i;
2413   1              
2414   1          //MDBSerialInit();
2415   1              length=Session(0x0f,VMCdata,1);
2416   1              if(length>=0x80) return length;
2417   1          else
2418   1          {
2419   2                for(i=0;i<length;i++)
2420   2                {
2421   3                  buf[i]=sysMDBMission.buff[i];
2422   3                      sysMDBMission.coinIDENTITYBuf[i] = buf[i];
2423   3                }
2424   2                *len=length;
2425   2                return 0x00;
2426   2          }    
2427   1      }
2428          
2429          //------------------------------------------------------------------------------
2430          //0x80: comms error
2431          //0x00: ok
2432          //none
2433          uchar MDB_Coin_EXP_FeatureEnable(uchar dat1,uchar dat2,uchar dat3,uchar dat4) 
2434          {
2435   1              uchar VMCdata[5]={0x01, 0x00, 0x00, 0x00, 0x00 };
2436   1              VMCdata[1]=dat1;
2437   1              VMCdata[2]=dat2;
2438   1              VMCdata[3]=dat3;
2439   1              VMCdata[4]=dat4;        
2440   1          //MDBSerialInit();
2441   1          return Session(0x0f,VMCdata,5);
2442   1      }
2443          
2444          //------------------------------------------------------------------------------
2445          //0x80: comms error
2446          //0x00: ok
2447          //none
2448          uchar MDB_Coin_EXP_Payout(uchar dat) 
2449          {
2450   1          uchar VMCdata[2]={0x02, 0x00 };
2451   1          VMCdata[1]=dat;
2452   1          MDBSerialInit();
2453   1          return Session(0x0f,VMCdata,2);
2454   1      }
2455          
2456          //------------------------------------------------------------------------------
2457          //0x80: comms error
2458          //0x00: busy, none coin payouted
2459          //0x01: There is/are coin(s) payouted
2460          uchar MDB_Coin_EXP_PayoutStatus(uchar *buf,uchar *len) 
2461          {
2462   1              uchar VMCdata[1]={0x03};
2463   1              uchar length;
2464   1              uchar i,j;
2465   1              
2466   1          MDBSerialInit();
2467   1          length=Session(0x0f,VMCdata,1);
2468   1          if(length>=0x80) return length;
2469   1          else
2470   1          {
2471   2                  for(i=0;i<length;i++)
CX51 COMPILER V7.50   ITL                                                                  10/23/2014 09:48:34 PAGE 41  

2472   2                  {
2473   3                      buf[i]=sysMDBMission.buff[i];
2474   3                      if(sysMDBMission.buff[i]!=0)
2475   3                              j=0xff;
2476   3                  }
2477   2              *len=length;
2478   2              if(j) return 0x01;
2479   2              else return 0x00; 
2480   2          }    
2481   1      }
2482          
2483          //------------------------------------------------------------------------------
2484          //0x80: comms error
2485          //0x00: ACK(Payout finished)
2486          //0x01: There is/are coin(s) payouted  
2487          uchar MDB_Coin_EXP_PayoutValuePoll(uchar *dat)
2488          {
2489   1          uchar VMCdata[1]={0x04};
2490   1          uchar length;
2491   1              
2492   1          MDBSerialInit();
2493   1          length=Session(0x0f,VMCdata,1);
2494   1          if(length>=0x80) return length;
2495   1          else
2496   1          {
2497   2                      *dat=sysMDBMission.buff[0];
2498   2              if(length==0) return 0x00;
2499   2              else return 0x01;
2500   2          }    
2501   1      }
2502          
2503          
2504          //------------------------------------------------------------------------------
2505          //0x80: comms error
2506          //0x00: not
2507          //0x01: Get status finished
2508          //;by gzz 20110825
2509          uchar MDB_Coin_EXP_TubeRemoved(void)
2510          {
2511   1          uchar VMCdata[1]={0x05};
2512   1          uchar length;
2513   1              
2514   1          MDBSerialInit();
2515   1          length=Session(0x0f,VMCdata,1);
2516   1          if(length>=0x80) 
2517   1              return length;
2518   1          else
2519   1          {   
2520   2                  sysMDBMission.tubeRemoved = 0;
2521   2              if(length==0) 
2522   2                      return 0x00;
2523   2              else
2524   2              {
2525   3                  if(sysMDBMission.buff[0]==0x15)
2526   3                  {
2527   4                      if(sysMDBMission.buff[1]==0x02)
2528   4                      {
2529   5                              sysMDBMission.tubeRemoved = 1;                          
2530   5                      }                 
2531   4                  }
2532   3                  return 0x01;
2533   3              }        
CX51 COMPILER V7.50   ITL                                                                  10/23/2014 09:48:34 PAGE 42  

2534   2          }    
2535   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   8711    ----
   CONSTANT SIZE    =     32    ----
   XDATA SIZE       =    769     484
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----       3
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


CX51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
